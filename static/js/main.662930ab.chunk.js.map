{"version":3,"sources":["resources/icons/all.svg","components/NavigationBar.tsx","components/Slider.tsx","model/util.ts","components/Graph.tsx","components/NodeDetails.tsx","components/NodeDetailsWrapper.tsx","components/PassiveDagAside.tsx","model/sat-node.ts","model/unit.ts","model/literal.ts","model/unit-parser.ts","model/traversal.ts","model/substitution.ts","model/dag.ts","model/transformations.ts","model/callViz.js","model/viz-wrapper.ts","components/PassiveDagModal.tsx","components/Main.tsx","components/GraphMenu.tsx","components/NodeMenu.tsx","components/Search.tsx","components/NodeCard.tsx","components/Aside.tsx","model/clause-orientation.ts","model/serialization.ts","components/App.tsx","model/find-node.ts","components/AppWrapper.tsx","components/LoadSavedProblemButton.tsx","components/Menu.tsx","components/Router.tsx","serviceWorker.js","index.tsx"],"names":["module","exports","icons","require","NavigationBar","React","render","id","onClick","window","history","back","viewBox","className","xlinkHref","this","props","name","onSave","Slider","slider","historyLength","currentTime","onCurrentTimeChange","disabled","ref","type","min","max","value","onChange","getSliderValue","current","parseInt","SatVisAssertionError","Error","constructor","message","super","assert","condition","styleTemplates","Graph","markers","Set","network","networkNodes","DataSet","networkEdges","graphContainer","dragStartEvent","cachedChangeNodesEvent","undefined","componentDidMount","generateNetwork","updateNetwork","selectNodes","nodeSelection","fit","componentDidUpdate","prevProps","dag","animateDagChanges","nodes","map","nodeId","toString","animation","incomingEvent","changedNodesEvent","visNodes","Array","has","visNode","label","get","toHTMLString","push","update","Network","edges","physics","interaction","multiselect","on","clickEvent","a","length","clickedNodeId","originalEvent","event","srcEvent","metaKey","ctrlKey","find","onNodeSelectionChange","filter","concat","dragEndEvent","isPassiveDag","deltaX","pointer","canvas","x","deltaY","y","onUpdateNodePositions","onlyUpdateStyles","visEdges","edgeId","nodePartition","styleMap","computeNodePartition","satNodeId","satNode","nodeStyle","hidden","toVisNode","getPosition","parents","parentId","visEdge","toVisEdge","clear","add","nodesInActiveDag","computeNodesInActiveDag","Map","node","isDeleted","deletionTime","nodeIsTheoryAxiom","set","isFromPreprocessing","inferenceRule","activeTime","style","position","styleData","isMarked","labelHighlightBold","shape","color","border","markedStyle","defaultStyle","background","highlight","highlightStyle","font","text","multi","Math","round","parentNodeId","arrows","from","to","smooth","findNodeAt","clickPosition","getNodeAt","layerX","layerY","toggleMarker","delete","NodeDetails","state","draggable","keep","toList","clause","orientation","literals","premiseLiterals","conclusionLiterals","contextLiterals","options","group","tag","_items","_sortable","onLiteralOrientationChange","oldIndex","newIndex","literal","index","toListItem","key","data-id","onDoubleClick","onLiteralRepresentationChange","currentTarget","innerText","statisticsStrings","numberOfTransitiveActivatedChildren","statistics","includes","infoToggle","title","onToggleInfo","editToggle","onToggleEdit","unit","string","onMouseEnter","setState","onMouseLeave","NodeDetailsWrapper","PassiveDagAside","selectClauseButtonEnabled","onSelectButtonPressed","SatNode","newTime","deletionParents","isBoundary","copy","isActive","Formula","formula","Clause","literalsNewEvent","literalsActiveEvent","changeLiteralOrientation","oldPosition","newPosition","removedLiterals","splice","removedLiteral","orientationReason","join","premiseString","isSelected","conclusionString","contextString","premiseStringWithoutBoldness","conclusionStringWithoutBoldness","contextStringWithoutBoldness","estimatedLengthOfLine","ceil","line","repeat","implication","Literal","args","negated","representation","hideBracketsAssoc","nonStrictForNegatedStrictInequalities","literalInParent","setLiteralInParent","switchToNextRepresentation","negateLiteral","occursNegated","switchSides","lhs","rhs","symbol","arg","Term","isVariable","startsWith","inner","UnitParser","match","parseClause","parseLiterals","literalStrings","split","i","parseLiteral","equalityPosition","search","substring","lhsString","rhsString","parseTerm","atomString","literalTerm","tokens","stringPos","char","tokenEnd","token","stack","pos","pop","f","DFPostOrderTraversal","todo","visited","leaves","hasNext","last","getNext","currentId","currentNode","existsUnvisitedParent","ReversePostOrderTraversal","postOrder","it","literalsMatch","literal1","literal2","allowSubstitutions","success","substitution","arg1","arg2","computeSubstitution","substitutionEq","isSubstitution","termsAreEqual","isEqual","f1","f2","substitutedVariable","ParsedLine","unitString","Dag","mergeMap","activeNodeId","nonLeaves","values","keys","maximalActiveTime","isEmpty","size","getChildren","children","counter","transitiveChildrenIds","iterator","existsRelevantParent","isRelevant","alreadyGenerated","alreadyActivated","nodeIsInputNode","parsedLines","existingDag","emptyClauseNode","parentsAfterMerge","mergedParentsOrUndefined","parsePreprocessingUnit","parent","literalsAfterActivation","nSel","existingLiteralsActiveOrder","foundMatch","existingLiteral","computeActiveNodes","activeNodeIds","nodeIds","currentNodeId","isRefutation","filterNonParents","relevantIds","transitiveParentIds","remainingNodes","forEach","remainingNodesDeepCopy","filterNonConsequences","boundaryNode","createBoundaryNode","mergePreprocessing","nodeIdsToRemove","postOrderTraversal","updatedParents","parentNode","parent2Id","updatedNode","nodeIdToRemove","passiveDagForSelection","selectionIds","selectionIdsSet","foundNodes","idToActiveDagParents","activeDagParents","activeDagParentsParent","activeDagParent","passiveDagNodes","relevantNodes","iterator2","runViz","dotString","viz","Viz","Module","renderString","format","then","result","catch","error","console","PLAIN_PATTERN","VizWrapper","layoutNodes","sourceNode","isSourceNode","posSelectedX","posSelectedY","posSourceX","posSourceY","onlyActiveDag","dagToDotString","layoutString","parseLayoutString","nodesToDotString","Number","MAX_SAFE_INTEGER","inputStrings","preprocessingStrings","otherStrings","edgeStrings","nodeStrings","firstEdgeLineIndex","indexOf","parsedNodeLines","substr","slice","matchAll","next","parsedNodeLine","idString","xString","yString","parseFloat","ReactModal","setAppElement","PassiveDagModal","passiveDag","nodeSelectionPassiveDag","generatePassiveDag","previousProps","isOpen","contentLabel","onRequestClose","onDismissPassiveDag","nodeSelectionChange","bind","updateNodePositions","onUpdateNodeSelection","selectButtonPressed","selection","delta","layoutDag","posCurrentX","posCurrentY","posPassiveX","posPassiveY","selectedId","positioningHint","Main","modal","showPassiveDag","readOnly","GraphMenu","undoEnabled","onUndo","filterUpEnabled","onRenderParentsOnly","filterDownEnabled","onRenderChildrenOnly","passiveDagButtonEnabled","onShowPassiveDag","NodeMenu","onSelectParents","onSelectChildren","onSelectCommonConsequences","Search","searchField1","searchField2","searchField3","getDisabledListItem","placeholder","onKeyUp","searchString1","searchString2","searchString3","candidates","foundLiteral","sort","node1","node2","clause1","clause2","NodeCard","Aside","multipleVersions","graphMenuEnabled","filtersEnabled","computeParentLiteralsCase1","parentLiterals","parentLiteral","computeParentLiteralsCase2","allowMultipleRemovals","foundRemovedLit","j","computeParentLiteralsCase3","allowSimultanousSuperposition","foundRewrittenLiteral","computeParentLiterals","parentClause","leftNode","rightNode","leftClause","rightClause","leftWasAlreadyActivated","rightWasAlreadyActivated","leftLiterals","rightLiterals","computeClauseRepresentation","changedClauseId","changedClauses","isEqualityResolutionWithDeletion","propagateSingleParent","propagateTwoParents","l","existsUserOrientedLiteral","premiseIndexMap","conclusionIndexMap","contextIndexMap","lit1","lit2","index1","index2","Serializer","version","problem","vampireUserOptions","obj","JSON","stringify","convertToIndices","encodedLiterals","encodedPremiseLiterals","encodedConclusionLiterals","encodedContextLiterals","encodedLiteralsActiveEvent","entries","json","res","parse","reconstructDag","pairIdNode","reconstructSatNode","reconstructUnit","pair","reconstructLiteral","n","term","reconstructTerm","AppMode","App","Component","dags","nodeIdToActivate","main","mode","saved","updateNodeSelection","updateCurrentTime","dismissPassiveDag","changeLiteralRepresentation","toggleInfo","toggleEdit","undoLastStep","renderParentsOnly","renderChildrenOnly","selectParents","selectChildren","selectCommonConsequences","deserializeAppState","loadedProblem","runVampire","manualcs","selectFinalPreprocessingClauses","serialize","serializeAppState","logging","log","jsonToParsedLines","lines","val","lineType","unitId","url","fetch","method","headers","body","file","fetchedJSON","status","vampireState","proof","fromParsedLines","orientClauses","setLiteralOptions","errorMessage","selectClause","currentDag","currentDagActiveNodes","newDag","newDagActiveNodes","newNodes","layoutNodesAtPosition","stop","popDag","pushDag","newSelection","childId","commonConsequences","idToRelevantParentIds","relevantParents","relevantParentIdsFromParent","relevantParentId","findCommonConsequences","changedNodes","selectedNodesInNewDag","AppWrapper","app","loadedProblemName","save","saveData","element","document","createElement","Blob","href","URL","createObjectURL","download","generateFilename","appendChild","click","prefix","LoadSavedProblemButton","useHistory","fileUpload","target","files","reader","FileReader","onloadend","onLoadSavedProblemData","readAsText","Menu","isChromeOrFirefox","navigator","userAgent","monacoDiv","monaco","Monaco","create","lineNumbers","roundedSelection","scrollBeyondLastLine","scrollBeyondLastColumn","minimap","enabled","renderLineHighlight","hideCursorInOverviewRuler","links","overviewRulerBorder","automaticLayout","lineDecorationsWidth","lineNumbersMinChars","wordWrap","setValue","getModel","onDidChangeContent","onChangeProblem","getValue","problemName","chooseFile","uploadEncoding","htmlFor","changeInputSyntax","inputSyntax","changeVampireUserOptions","checked","changeHideBracketsAssoc","changeNonStrictForNegatedStrictInequalities","changeOrientClauses","changeLogging","onChangeProblemName","endsWith","onChangeInputSyntax","newValue","onChangeVampireUserOptions","changeTextArea","onChangeHideBracketsAssoc","onChangeNonStrictForNegatedStrictInequalities","onChangeOrientClauses","onChangeLogging","AppRouter","path","exact","changeProblem","changeProblemName","loadSavedProblem","appComponent","saturation","problemData","filename","Boolean","location","hostname","ReactDOM","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.662930ab.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/all.0974d87f.svg\";","import * as React from 'react';\nimport './NavigationBar.css';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  name: string,\n  onSave: () => void\n}\n\nexport class NavigationBar extends React.Component<Props, {}> {\n\n  render() {\n    return (\n      <nav id=\"navigationBar\">\n        <button onClick={() => window.history.back()}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon\">\n            <use xlinkHref={`${icons}#nav-back`}/>\n          </svg>\n          <span>Back</span>\n        </button>\n        <small>{this.props.name}</small>\n        <button id=\"saveButton\" onClick={() => this.props.onSave()}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon\">\n            <use xlinkHref={`${icons}#save-download`}/>\n          </svg>\n          <span>Save</span>\n        </button>\n      </nav>\n    )\n  }\n}","import * as React from 'react';\n\nimport './Slider.css';\n\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  historyLength: number,\n  currentTime: number,\n  onCurrentTimeChange: (newState: number) => void,\n};\nexport default class Slider extends React.Component<Props, {}> {\n\n  private slider = React.createRef<HTMLInputElement>();\n\n  render() {\n    const {historyLength, currentTime, onCurrentTimeChange} = this.props;\n\n    return (\n      <section className=\"component-slider\">\n\n        <button disabled={currentTime <= 0} onClick={() => onCurrentTimeChange(currentTime - 1)}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon\">\n            <use xlinkHref={`${icons}#history-back`}/>\n          </svg>\n        </button>\n\n        <section className=\"wrapper\">\n          <input\n            ref={this.slider}\n            type=\"range\"\n            min={0}\n            max={historyLength}\n            value={currentTime}\n            onChange={() => onCurrentTimeChange(this.getSliderValue())}\n          />\n        </section>\n\n        <button disabled={currentTime >= historyLength} onClick={() => onCurrentTimeChange(currentTime + 1)}>\n          <svg viewBox=\"0 0 24 24\" className=\"icon\">\n            <use xlinkHref={`${icons}#history-forward`}/>\n          </svg>\n        </button>\n\n      </section>\n    );\n  }\n\n  // HELPERS ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  getSliderValue(): number {\n    return this.slider.current ? parseInt(this.slider.current.value, 10) : 0;\n  }\n\n}\n","class SatVisAssertionError extends Error {\n    constructor(message) {\n      super(message);\n      this.name = \"SatVisAssertionError\";\n    }\n  }\n\nexport function assert(condition, message=\"\") {\n    if (!condition)\n        throw new SatVisAssertionError('Assertion failed: ' + (message || ''));\n};","import * as React from 'react';\nimport {DataSet, Network, IdType, Node, Edge} from 'vis'\n\nimport './Graph.css'\nimport { assert } from '../model/util';\n\nimport { Dag } from '../model/dag';\nimport SatNode from '../model/sat-node';\n\nconst styleTemplates = require('../resources/styleTemplates');\n\ntype Props = {\n  dag: Dag,\n  nodeSelection: number[],\n  changedNodesEvent?: Set<number>,\n  currentTime: number,\n  animateDagChanges: boolean,\n  onNodeSelectionChange: (selection: number[]) => void,\n  onUpdateNodePositions: (nodeIds: Array<number>, delta: [number, number]) => void\n};\n\nexport default class Graph extends React.Component<Props, {}> {\n\n  markers = new Set<number>();\n  network: Network | null = null;\n  networkNodes = new DataSet<Node>([]);\n  networkEdges = new DataSet<Edge>([]);\n  graphContainer = React.createRef<HTMLDivElement>();\n  dragStartEvent: any = null;\n  cachedChangeNodesEvent?: Set<number> = undefined;\n\n  componentDidMount() {\n    this.generateNetwork();\n    this.updateNetwork(false);\n    this.network!.selectNodes(this.props.nodeSelection);\n    this.network!.fit();\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (this.props.dag !== prevProps.dag) {\n      this.updateNetwork(false);\n      this.network!.selectNodes(this.props.nodeSelection);\n      if (this.props.animateDagChanges) {\n        // center the view to selected nodes\n        this.network!.fit({\n          nodes: this.props.nodeSelection.map(nodeId => nodeId.toString()), \n          animation: true\n        });\n      } else {\n        // set the view so that the whole graph is visible\n        this.network!.fit();\n      }\n    } else {\n      if (this.props.nodeSelection !== prevProps.nodeSelection) {\n        this.network!.selectNodes(this.props.nodeSelection);\n      }\n      if (this.props.currentTime !== prevProps.currentTime) {\n        this.updateNetwork(true);\n      }\n      const incomingEvent = this.props.changedNodesEvent;\n      if (incomingEvent !== prevProps.changedNodesEvent) {\n        assert(incomingEvent !== undefined);\n        if (incomingEvent !== this.cachedChangeNodesEvent) {\n          this.cachedChangeNodesEvent = incomingEvent;\n\n          // update all nodes from event which occur in the dag\n          const visNodes = new Array<Node>();\n          for (const nodeId of incomingEvent!) {\n            if (this.props.dag.nodes.has(nodeId)) {\n              const visNode = {\n                id : nodeId,\n                label : this.props.dag.get(nodeId).toHTMLString(this.props.currentTime)\n              };\n              visNodes.push(visNode);\n            }\n          }\n          this.networkNodes.update(visNodes);\n        }\n      }\n    }\n  }\n\n  render() {\n    return (\n      <section className=\"component-graph\" ref={this.graphContainer}>\n        <canvas/>\n      </section>\n    );\n  }\n\n\n  // DISPLAY NETWORK ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  generateNetwork() {\n    assert(this.graphContainer.current);\n    assert(!this.network); // should only be called once\n\n    this.network = new Network(this.graphContainer.current!, {\n      nodes: this.networkNodes,\n      edges: this.networkEdges\n    }, {\n      physics: false,\n      interaction: {\n        multiselect: false\n      },\n    });\n\n    this.network.on('click', async (clickEvent) => {\n      if (clickEvent.nodes.length > 0) {\n        assert(clickEvent.nodes.length === 1);\n        const clickedNodeId = clickEvent.nodes[0];\n        \n        const originalEvent = clickEvent.event.srcEvent;\n        assert(originalEvent !== undefined && originalEvent !== null);\n\n        if (originalEvent.metaKey || originalEvent.ctrlKey) {\n          // note standard conventions:\n          // - on macOS, the command key (which maps on macOS to metaKey) is used for selecting multiple elements\n          // - on windows and linux, the ctrl key is used for selecting multiple elements\n          // we therefore check whether any of these keys is pressed\n          // this has the following side-effects, which we don't care about, at least for now: \n          // - one can use the ctrl key on macOS too for selecting multiple elements\n          // - one can use the windows key (which maps on windows to metaKey) too for selecting multiple elements\n          if (this.props.nodeSelection.find((nodeId: number) => nodeId === clickedNodeId) !== undefined) {\n            this.props.onNodeSelectionChange(this.props.nodeSelection.filter((nodeId: number) => nodeId !== clickedNodeId));\n          } else {\n            this.props.onNodeSelectionChange(this.props.nodeSelection.concat(clickEvent.nodes));\n          }\n        } else {\n          this.props.onNodeSelectionChange(clickEvent.nodes);\n        }\n      } else {\n        this.props.onNodeSelectionChange([]);\n      }\n    });\n\n    this.network.on('dragStart', (dragStartEvent) => {\n      assert(dragStartEvent !== undefined && dragStartEvent !== null);\n      assert(dragStartEvent.nodes !== undefined && dragStartEvent.nodes !== null);\n      this.dragStartEvent = dragStartEvent;\n      if (dragStartEvent.nodes.length > 0) {\n        this.props.onNodeSelectionChange(dragStartEvent.nodes);\n      }\n    });\n\n    this.network.on('dragEnd', (dragEndEvent) => {\n      assert(this.dragStartEvent !== undefined && this.dragStartEvent !== null);\n      assert(this.dragStartEvent.nodes !== undefined && this.dragStartEvent.nodes !== null);\n      assert(dragEndEvent !== undefined && dragEndEvent !== null);\n      assert(dragEndEvent.nodes !== undefined && dragEndEvent.nodes !== null);\n      if (dragEndEvent.nodes.length > 0 && !this.props.dag.isPassiveDag) {\n        const deltaX = dragEndEvent.pointer.canvas.x - this.dragStartEvent.pointer.canvas.x;\n        const deltaY = dragEndEvent.pointer.canvas.y - this.dragStartEvent.pointer.canvas.y;\n        this.props.onUpdateNodePositions(dragEndEvent.nodes as Array<number>, [deltaX / (-70), deltaY / (-120)]);\n      }\n    });\n  }\n\n  // updates the network displayed by Vis.js\n  // if onlyUpdateStyles is false, all nodes and edges are newly generated.\n  // if onlyUpdateStyles is true, only the attributes of the nodes and edges are updated\n  updateNetwork(onlyUpdateStyles: boolean) {\n    const {dag, currentTime} = this.props;\n\n    const visNodes = new Array<Node>();\n    const visEdges = new Array<Edge>();\n    let edgeId = 0;\n\n    // partition nodes:\n    // for standard dags, compute node partition\n    // for passive dags use style map cached in dag\n    const nodePartition = dag.isPassiveDag ? (dag.styleMap as Map<number, string>) : this.computeNodePartition(dag, currentTime);\n\n    // update network nodes\n    for (const [satNodeId, satNode] of dag.nodes) {\n      const nodeStyle = nodePartition.get(satNodeId);\n      assert(nodeStyle !== undefined, \"invar\");\n      if (nodeStyle === \"hidden\") {\n        const visNode = {id : satNodeId, hidden : true};\n        visNodes.push(visNode);\n      } else {\n        const visNode = this.toVisNode(satNode, nodeStyle, satNode.getPosition());\n        visNodes.push(visNode);\n      }\n\n      for (const parentId of satNode.parents) {\n        const visEdge = this.toVisEdge(edgeId, parentId, satNode.id, nodeStyle === \"hidden\");\n        edgeId = edgeId + 1;\n        visEdges.push(visEdge);\n      }\n    }\n\n    if(onlyUpdateStyles) {\n      // QUESTION: it seems that using a single call to update is faster than separately updating each node. is this true?\n      this.networkNodes.update(visNodes);\n      this.networkEdges.update(visEdges);\n    } else {\n      // QUESTION: it seems that using a single call to add is faster than separately adding each node. is this true?\n      this.networkNodes.clear();\n      this.networkNodes.add(visNodes);\n      this.networkEdges.clear();\n      this.networkEdges.add(visEdges);\n    }\n  }\n\n  computeNodePartition(dag: Dag, currentTime: number): Map<number, any> {\n\n    const nodesInActiveDag = dag.computeNodesInActiveDag(currentTime);\n\n    const nodePartition = new Map<number, any>();\n    for (const [nodeId, node] of dag.nodes) {\n\n      const isDeleted = (node.deletionTime !== null && node.deletionTime <= currentTime);\n\n      if (dag.nodeIsTheoryAxiom(nodeId)) {\n        nodePartition.set(nodeId, isDeleted ? \"theory-axiom-deleted\" : \"theory-axiom\");\n        continue;\n      }\n      if (node.isFromPreprocessing) {\n        if (node.inferenceRule === \"negated conjecture\") {\n          nodePartition.set(nodeId, \"conjecture\");\n        } else {\n          nodePartition.set(nodeId, isDeleted ? \"preprocessing-deleted\" : \"preprocessing\");\n        }\n        continue;\n      }\n\n      const isActivated = (node.activeTime !== null && node.activeTime <= currentTime);\n      if (isActivated) {\n        nodePartition.set(nodeId, isDeleted ? \"activated-deleted\" : \"activated\");\n        continue;\n      }\n\n      if (nodesInActiveDag.has(nodeId)) {\n        nodePartition.set(nodeId, \"deleted\");\n        continue;\n      } \n\n      nodePartition.set(nodeId, \"hidden\");\n    }\n\n    return nodePartition;\n  }\n\n  toVisNode(node: SatNode, style: string, position: [number, number]): any {\n    const styleData = styleTemplates[style];\n    const isMarked = this.markers.has(node.id);\n\n    return {\n      id : node.id,\n      label : node.toHTMLString(this.props.currentTime),\n      labelHighlightBold : false,\n      shape : \"box\",\n      color : {\n        border : isMarked ? styleData.markedStyle.border : styleData.defaultStyle.border,\n        background : isMarked ? styleData.markedStyle.background : styleData.defaultStyle.background,\n        highlight : {\n          border : styleData.highlightStyle.border,\n          background : styleData.highlightStyle.background\n        }\n      },\n      font : {\n        color : styleData.text,\n        multi : true\n      },\n      hidden : false,\n      x : Math.round(position[0] * -70),\n      y : Math.round(position[1] * -120)\n    };\n\n  }\n\n  toVisEdge(edgeId: number, parentNodeId: number, nodeId: number, hidden: boolean) {\n    return {\n      id : edgeId,\n      arrows : \"to\",\n      color : {\n        color : \"#dddddd\",\n        highlight : \"#f8cfc1\",\n      },\n      from : parentNodeId,\n      to : nodeId,\n      smooth : false,\n      hidden : hidden\n    }\n  }\n\n\n  // INTERACTION ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  findNodeAt(clickPosition: {layerX: number, layerY: number}): IdType  {\n    return this.network!.getNodeAt({\n      x: clickPosition.layerX,\n      y: clickPosition.layerY\n    });\n  }\n\n  // MARKERS ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  toggleMarker(nodeId: number) {\n    assert(this.networkNodes);\n\n    if (this.markers.has(nodeId)) {\n      this.markers.delete(nodeId);\n    } else {\n      this.markers.add(nodeId);\n    }\n    this.updateNetwork(true);\n  }\n\n}\n","import * as React from 'react';\n\nimport './NodeDetails.css';\nimport Sortable from 'react-sortablejs';\nimport {Clause} from '../model/unit';\nimport {Literal} from '../model/literal';\nimport SatNode from '../model/sat-node';\nimport {assert} from '../model/util';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  node: SatNode,\n  numberOfTransitiveActivatedChildren: number,\n  infoToggle: boolean,\n  editToggle: boolean,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void,\n  onToggleInfo: () => void,\n  onToggleEdit: () => void\n};\n\nexport default class NodeDetails extends React.Component<Props, {}> {\n  state = {\n    draggable: false\n  };\n\n  keep=true; // hack to skip each second event generated by Sortable\n\n  render() {\n    const statisticsStrings = new Array<string>();\n    statisticsStrings.push(\"Childs: \" + this.props.numberOfTransitiveActivatedChildren.toString());\n    for (let [key, value] of this.props.node.statistics) {\n      if (!['nSel', 'inD'].includes(key)) {\n        if (key === \"a\") {\n          key = \"Age\";\n        } else if (key === \"w\") {\n          key = \"Weight\";\n        }\n        statisticsStrings.push(`${key}: ${value}`);\n      }\n    }\n\n    return (\n      <section\n        className={'component-node-details details'}\n      >\n        <article>\n          <h2>Node <strong>{this.props.node.id}</strong></h2>\n\n          <div className=\"button-bar\">\n            <button\n              className={'toggle-button' + (this.props.infoToggle ? ' toggled': '')}\n              title={ this.props.infoToggle ? 'Hide statistics': 'Show statistics' }\n              onClick={this.props.onToggleInfo}\n            >\n              <svg viewBox=\"0 0 24 24\" className=\"icon\">\n                <use xlinkHref={`${icons}#toggle-info`}/>\n              </svg>\n            </button>\n            <button\n              className={'toggle-button' + (this.props.editToggle ? ' toggled': '')}\n              title={ this.props.editToggle ? 'Terminate edit mode': 'Enter edit mode' }\n              onClick={this.props.onToggleEdit}\n              disabled={this.props.node.unit.type !== 'Clause'}\n            >\n              <svg viewBox=\"0 0 24 24\" className=\"icon\">\n                <use xlinkHref={`${icons}#toggle-edit`}/>\n              </svg>\n            </button>\n          </div>\n\n          <h3>\n            {this.props.node.inferenceRule}\n          </h3>\n          {\n            this.props.infoToggle && <ul className=\"stats\">{ statisticsStrings.map((string, key) => <li key={key}>{string}</li>) }</ul>\n          }\n\n          {\n            (this.props.node.unit.type === 'Clause' && this.props.editToggle) ? (\n              <section\n                className={'literal-wrapper' + (this.state.draggable ? ' drag' : '')}\n                onMouseEnter={() => this.setState({draggable: true})}\n                onMouseLeave={() => this.setState({draggable: false})}\n              >\n                {\n                  this.toList(this.props.node.id, this.props.node.unit as Clause, \"premise\")\n                }\n                <span className={'separator separator-arrow count-' + (this.props.node.unit as Clause).premiseLiterals.length}>{'\\u2192'}</span>\n                {\n                  this.toList(this.props.node.id, this.props.node.unit as Clause, \"conclusion\")\n                }\n                <span className={'separator separator-line count-' + (this.props.node.unit as Clause).contextLiterals.length}>&nbsp;</span>\n                {\n                  this.toList(this.props.node.id, this.props.node.unit as Clause, \"context\")\n                }\n              </section>\n            ) : (\n              <section className={'literal-wrapper read-mode'}>\n                {\n                  this.props.node.unit.toHTMLString(false)\n                }\n              </section>\n            )\n          }\n        </article>\n      </section>\n    );\n  }\n\n  toList = (nodeId: number, clause: Clause, orientation: \"premise\" | \"conclusion\" | \"context\") => {\n    const literals = orientation === \"premise\" ? clause.premiseLiterals : (orientation === \"conclusion\" ? clause.conclusionLiterals : clause.contextLiterals);\n\n    return (\n      <Sortable\n        options={{\n          group: 'shared'\n        }}\n        tag={\"ul\"}\n        id={orientation === \"premise\" ? \"id1\" : (orientation === \"conclusion\" ? \"id2\" : \"id3\")}\n        onChange={(_items, _sortable, event)=>{\n          // Hack: If from and to are different, then Sortable generates two identical events (one for each modified list), \n          // so we ignore the latter one using the flag this.keep\n          const from = event.from.id === \"id1\" ? \"premise\" : event.from.id === \"id2\" ? \"conclusion\" : \"context\";\n          const to = event.to.id === \"id1\" ? \"premise\" : event.to.id === \"id2\" ? \"conclusion\" : \"context\";\n          if (from === to) {\n            assert(this.keep);\n          }\n          if (this.keep) {\n            this.props.onLiteralOrientationChange(nodeId, [from, event.oldIndex], [to, event.newIndex]);\n          }\n          if (from !== to) {\n            this.keep = !this.keep;\n          }\n        }}\n      >\n        {\n          literals.map((literal, index) => this.toListItem(literal, index, orientation))\n        }\n      </Sortable>\n      )\n    };\n\n  toListItem = (literal: Literal, index: number, orientation: \"premise\" | \"conclusion\" | \"context\") => {\n    return <li key={index} data-id={index} onDoubleClick={(event) => {\n      this.props.onLiteralRepresentationChange(this.props.node.id, literal);\n      event.currentTarget.innerText = literal.toString(orientation === \"premise\");\n    }}>{literal.toString(orientation === \"premise\")}</li>\n  };\n}\n","import * as React from 'react';\nimport { Dag } from '../model/dag';\n\nimport NodeDetails from '../components/NodeDetails'\nimport { Literal } from '../model/literal';\n\ntype Props = {\n  dag: Dag | null,\n  nodeSelection: number[],\n  currentTime: number,\n  infoToggle: boolean,\n  editToggle: boolean,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: ['premise' | 'conclusion' | 'context', number], newPosition: ['premise' | 'conclusion' | 'context', number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void,\n  onToggleInfo: () => void,\n  onToggleEdit: () => void\n};\n\nexport class NodeDetailsWrapper extends React.Component<Props, {}> {\n\n  render() {\n    if (this.props.nodeSelection.length === 1) {\n      const node = this.props.dag!.get(this.props.nodeSelection[0]);\n      return (\n        <NodeDetails\n          node={node}\n          numberOfTransitiveActivatedChildren={this.props.dag!.numberOfTransitiveActivatedChildren(node.id, this.props.currentTime)}\n          infoToggle={this.props.infoToggle}\n          editToggle={this.props.editToggle}\n          onLiteralOrientationChange={this.props.onLiteralOrientationChange}\n          onLiteralRepresentationChange={this.props.onLiteralRepresentationChange}\n          onToggleInfo={this.props.onToggleInfo}\n          onToggleEdit={this.props.onToggleEdit}\n        />\n      )\n    } else {\n      return (\n        <section className={'component-node-details overview'}>\n          <small id=\"nodeInfo\"><strong>{`${this.props.nodeSelection.length} nodes`}</strong> selected</small>\n        </section>\n      )\n    }\n  }\n}","import * as React from 'react';\n\nimport { Dag } from '../model/dag';\nimport { Literal } from '../model/literal';\nimport { assert } from '../model/util';\nimport { NodeDetailsWrapper } from './NodeDetailsWrapper';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\n\ntype Props = {\n  dag: Dag,\n  currentTime: number,\n  nodeSelection: number[],\n  infoToggle: boolean,\n  editToggle: boolean,\n  onUpdateNodeSelection: (selection: number[]) => void,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void\n  onSelectButtonPressed: () => void,\n  onToggleInfo: () => void,\n  onToggleEdit: () => void\n};\nexport class PassiveDagAside extends React.Component<Props, {}> {\n\n  render() {\n    assert(this.props.dag.isPassiveDag);\n    assert(this.props.dag.styleMap !== null);\n    const selectClauseButtonEnabled = this.props.nodeSelection.length === 1 && this.props.dag.styleMap!.get(this.props.nodeSelection[0]) === \"passive\";\n\n    return (\n      <aside className=\"component-passive-aside\">\n        <section className=\"component-graph-menu\">\n          <button title=\"Select clauses\"\n                  disabled={!selectClauseButtonEnabled}\n                  onClick={() => { this.props.onSelectButtonPressed();}}>\n            <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n              <use xlinkHref={`${icons}#graph-s`}/>\n            </svg>\n          </button>\n        </section>\n        <NodeDetailsWrapper\n          dag={this.props.dag}\n          nodeSelection={this.props.nodeSelection}\n          currentTime={this.props.currentTime}\n          infoToggle={this.props.infoToggle}\n          editToggle={this.props.editToggle}\n          onLiteralOrientationChange={this.props.onLiteralOrientationChange}\n          onLiteralRepresentationChange={this.props.onLiteralRepresentationChange}\n          onToggleInfo={this.props.onToggleInfo}\n          onToggleEdit={this.props.onToggleEdit}\n        />\n      </aside>\n    );\n  }\n\n}\n","import { assert } from './util'\nimport { Unit } from './unit'\n\nexport default class SatNode {\n\n  readonly id: number;\n  unit: Unit;\n  readonly inferenceRule: string;\n  readonly parents: number[];\n  statistics: Map<string,number>;\n  readonly isFromPreprocessing: boolean;\n  newTime: number | null;\n  activeTime: number | null;\n  deletionTime: number | null;\n  deletionParents: number[];\n  position: [number,number] | null;\n  isBoundary: boolean;\n\n  constructor(\n    id: number,\n    unit: Unit,\n    inferenceRule: string,\n    parents: number[],\n    statistics: Map<string,number>,\n    isFromPreprocessing: boolean,\n    newTime: number | null,\n    activeTime: number | null,\n    deletionTime: number | null,\n    deletionParents: number[],\n    isBoundary: boolean\n  ) {\n    this.id = id;\n    this.unit = unit;\n    this.inferenceRule = inferenceRule;\n    this.parents = parents;\n    this.statistics = statistics;\n    this.isFromPreprocessing = isFromPreprocessing;\n    this.newTime = newTime;\n    this.activeTime = activeTime;\n    this.deletionTime = deletionTime;\n    this.deletionParents = deletionParents;\n    this.position = null;\n    this.isBoundary = isBoundary;\n  }\n\n  // return a copy of this node, where the position is null\n  copy(): SatNode {\n    return new SatNode(this.id, this.unit, this.inferenceRule, this.parents, this.statistics, this.isFromPreprocessing, this.newTime, this.activeTime, this.deletionTime, this.deletionParents, this.isBoundary);\n  }\n\n  getPosition(): [number,number] {\n    assert(this.position !== null, `accessing position of node with id ${this.id}, which has not been computed`);\n    return this.position as [number,number];\n  }\n\n  toString(): string {\n    return this.unit.toString();\n  }\n\n  toHTMLString(currentTime: number): string {\n    const isActive = this.activeTime !== null && this.activeTime <= currentTime;\n    return this.unit.toHTMLString(isActive);\n  }\n}","import {assert} from './util'\nimport {Literal} from './literal'\n\n// a unit is either a Formula or a clause.\n// units are also used internally by Vampire.\n// we fully parse clauses, but we keep formulas as string.\n// fully parsing formulas is more involved, in particular if one wants to support a reasonably complete subset of tptp.\nexport type Unit = Formula | Clause;\n\nexport class Formula {\n  readonly type: \"Formula\" | \"Clause\";\n  readonly formula: string;\n  \n  constructor(formula: string) {\n    this.type = \"Formula\";\n    this.formula = formula;\n  }\n\n  toString(): string {\n    return this.formula;\n  }\n\n  toHTMLString(isActive: boolean): string {\n    return this.formula;\n  }\n}\n\nexport class Clause {\n  readonly type: \"Formula\" | \"Clause\";\n  readonly literalsNewEvent: Literal[];\n\n  // literalsNewEvent is partitioned into premiseLiterals, conclusionLiterals and contextLiterals\n  // the referenced literals are not only equal, but the same as the literals in literalsNewEvent\n  premiseLiterals: Literal[];\n  conclusionLiterals: Literal[];\n  contextLiterals: Literal[];\n  \n  // in order to compute literal flows we need to save the order in which literals occured in the clause\n  // not only at the timepoints of the new-event but also at the timepoint of the active-event.\n  // the referenced literals are not only equal, but the same as the literals in literalsNewEvent\n  literalsActiveEvent: Literal[] | null;\n\n  constructor(literalsNewEvent: Array<Literal>, premiseLiterals: Array<Literal>, conclusionLiterals: Array<Literal>, contextLiterals: Array<Literal>){\n    this.type = \"Clause\";\n    this.literalsNewEvent = literalsNewEvent;\n    this.premiseLiterals = premiseLiterals;\n    this.conclusionLiterals = conclusionLiterals;\n    this.contextLiterals = contextLiterals;\n    this.literalsActiveEvent = null;\n  }\n\n  changeLiteralOrientation(oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) {\n\n    // remove literal from old position\n    let removedLiterals: Array<Literal> | null = null;\n    if (oldPosition[0] === \"premise\") {\n      assert(0 <= oldPosition[1]);\n      assert(oldPosition[1] < this.premiseLiterals.length);\n      removedLiterals = this.premiseLiterals.splice(oldPosition[1], 1);\n    } else if (oldPosition[0] === \"conclusion\"){\n      assert(0 <= oldPosition[1]);\n      assert(oldPosition[1] < this.conclusionLiterals.length);\n      removedLiterals = this.conclusionLiterals.splice(oldPosition[1], 1);\n    } else {\n      assert(0 <= oldPosition[1]);\n      assert(oldPosition[1] < this.contextLiterals.length);\n      removedLiterals = this.contextLiterals.splice(oldPosition[1], 1);\n    }\n    assert(removedLiterals.length === 1);\n    const removedLiteral = removedLiterals[0];\n\n    // add literal to new position\n    if (newPosition[0] === \"premise\") {\n      assert(0 <= newPosition[1]);\n      assert(newPosition[1] <= this.premiseLiterals.length);\n      this.premiseLiterals.splice(newPosition[1], 0, removedLiteral);\n    } else if (newPosition[0] === \"conclusion\") {\n      assert(0 <= newPosition[1]);\n      assert(newPosition[1] <= this.conclusionLiterals.length);\n      this.conclusionLiterals.splice(newPosition[1], 0, removedLiteral);\n    } else {\n      assert(0 <= newPosition[1]);\n      assert(newPosition[1] <= this.contextLiterals.length);\n      this.contextLiterals.splice(newPosition[1], 0, removedLiteral);\n    }\n    removedLiteral.orientationReason = \"user\";\n  }\n\n  toString(): string {\n    if (this.premiseLiterals.length === 0 && this.conclusionLiterals.length === 0 && this.contextLiterals.length === 0) {\n      return \"$false\"; // empty clause\n    }\n    const literals = this.premiseLiterals.concat(this.conclusionLiterals, this.contextLiterals);\n    return literals.map(literal => literal.toString(false)).join(\" | \");\n  }\n\n  toHTMLString(isActive: boolean): string {\n    let premiseString = this.premiseLiterals\n      .map(literal => literal.isSelected ? (\"<b>\" + literal.toString(true) + \"</b>\") : literal.toString(true))\n      .join(\" & \");\n    let conclusionString = this.conclusionLiterals\n      .map(literal => literal.isSelected ? (\"<b>\" + literal.toString(false) + \"</b>\") : literal.toString(false))\n      .join(\" | \");\n    let contextString = this.contextLiterals\n      .map(literal => literal.isSelected ? (\"<b>\" + literal.toString(false) + \"</b>\") : literal.toString(false))\n      .join(\" | \");\n    let premiseStringWithoutBoldness = this.premiseLiterals\n      .map(literal => literal.toString(true))\n      .join(\" & \");\n    let conclusionStringWithoutBoldness = this.conclusionLiterals\n      .map(literal => literal.toString(false))\n      .join(\" | \");\n    let contextStringWithoutBoldness = this.contextLiterals\n      .map(literal => literal.toString(false))\n      .join(\" | \");\n    if(this.conclusionLiterals.length === 0) {\n      conclusionString = \"$false\";\n      conclusionStringWithoutBoldness = \"$false\";\n    }\n\n    // simple heuristic to estimate the length of the separating line between premise and conclusion.\n    const estimatedLengthOfLine = Math.ceil(Math.max(premiseStringWithoutBoldness.length, conclusionStringWithoutBoldness.length, contextStringWithoutBoldness.length) * 0.8);\n    const line = \"\\u2013\".repeat(estimatedLengthOfLine);\n\n    // don't use bold strings if clause is not activated yet\n    if (!isActive) {\n      premiseString = premiseStringWithoutBoldness;\n      conclusionString = conclusionStringWithoutBoldness;\n      contextString = contextStringWithoutBoldness;\n    }\n\n    const implication = this.premiseLiterals.length === 0 ? conclusionString : (premiseString + \"\\n\\u2192\\n\" + conclusionString);\n\n    return this.contextLiterals.length === 0 ? implication : (implication + \"\\n\" + line + \"\\n\" + contextString);\n  }\n}","import { assert } from \"./util\";\n\nexport class Literal {\n\treadonly name: string;\n\treadonly args: Term[];\n\treadonly negated: boolean;\n\tisSelected: boolean;\n\trepresentation: number;\n\thideBracketsAssoc: boolean;\n\tnonStrictForNegatedStrictInequalities: boolean;\n\tliteralInParent: Literal | null;\n\torientationReason: \"user\" | \"inherited\" | \"heuristic\" | \"none\";\n\n\tconstructor(name:string, args: Term[], negated: boolean){\n\t\tthis.name = name;\n\t\tthis.args = args;\n\t\tthis.negated = negated;\n\t\tthis.isSelected = false;\n\t\tthis.representation = 0; // 0 represents standard representation. Some literals may define other representations\n\t\tthis.hideBracketsAssoc = true;\n\t\tthis.nonStrictForNegatedStrictInequalities = true;\n\t\tthis.literalInParent = null;\n\t\tthis.orientationReason = \"none\";\n\t}\n\n\tsetLiteralInParent(literalInParent: Literal) {\n\t\tthis.literalInParent = literalInParent;\n\t}\n\n\tswitchToNextRepresentation() {\n\t\tif (this.name === \"$less\" || this.name === \"Sub\" || this.name === \"=\") {\n\t\t\tif (this.representation === 0) {\n\t\t\t\tthis.representation = 1;\n\t\t\t} else {\n\t\t\t\tthis.representation = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString(negateLiteral: boolean) : string {\n\t\tconst occursNegated = negateLiteral ? !this.negated : this.negated;\n\n\t\tif (this.name === \"=\") {\n\t\t\tassert(this.args.length === 2, \"equalities must have exactly two arguments\");\n\t\t\tconst switchSides = this.representation === 1;\n\t\t\tconst lhs = this.args[switchSides ? 1 : 0].toString(this.hideBracketsAssoc);\n\t\t\tconst rhs = this.args[switchSides ? 0 : 1].toString(this.hideBracketsAssoc);\n\t\t\treturn lhs + (occursNegated ? \" != \" : \" = \") + rhs;\n\t\t}\n\t\tif (this.name === \"$less\" || this.name === \"Sub\") {\n\t\t\tassert(this.args.length === 2, \"inequalities must have exactly two arguments\");\n\t\t\tconst switchSides = this.representation === 1;\n\t\t\tconst lhs = this.args[switchSides ? 1 : 0].toString(this.hideBracketsAssoc);\n\t\t\tconst rhs = this.args[switchSides ? 0 : 1].toString(this.hideBracketsAssoc);\n\t\t\tlet symbol;\n\t\t\tif (switchSides) {\n\t\t\t\tsymbol = occursNegated ? (this.nonStrictForNegatedStrictInequalities ? \" <= \" : \" !> \") : \" > \";\n\t\t\t} else {\n\t\t\t\tsymbol = occursNegated ? (this.nonStrictForNegatedStrictInequalities ? \" >= \" : \" !< \") : \" < \";\n\t\t\t}\n\t\t\treturn lhs + symbol + rhs;\n\t\t}\n\n\t\t// could also use logical-not-symbol: \"\\u00AC\"\n\t\treturn (occursNegated ? \"!\" : \"\") + this.name + \"(\" + this.args.map(arg => arg.toString(this.hideBracketsAssoc)).join(\",\") + \")\";\n\t}\n}\n\nexport class Term {\n\treadonly name: string;\n\treadonly args: Term[];\n\treadonly isVariable: boolean;\n\t\n\tconstructor(name: string, args: Term[]) {\n\t\tthis.name = name;\n\t\tthis.args = args;\n\t\tconst isVariable = name.startsWith(\"X\")\n\t\tthis.isVariable = isVariable;\n\t\tif(isVariable) {\n\t\t\tassert(this.args.length === 0);\n\t\t}\n\t}\n\n\ttoString(hideBracketsAssoc: boolean): string {\n\t\tlet name = this.name;\n\t\tif(this.name === \"$sum\") {\n\t\t\tname = \"+\";\n\t\t} else if(this.name === \"$uminus\") {\n\t\t\tname = \"-\";\n\t\t}\n\n\t\tif(this.args.length === 0){\n\t\t\treturn name;\n\t\t} else {\n\t\t\tif (name === \"+\"){\n\t\t\t\tconst inner = this.args.map(arg => arg.toString(hideBracketsAssoc)).join(\"+\");\n\t\t\t\tif (hideBracketsAssoc) {\n\t\t\t\t\treturn inner;\n\t\t\t\t} else {\n\t\t\t\t\treturn \"(\" + inner + \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn name + \"(\" + this.args.map(arg => arg.toString(hideBracketsAssoc)).join(\",\") + \")\";\n\t\t}\n\t}\n}\n\n\n\n","import {assert} from './util'\nimport {Unit, Formula, Clause} from './unit'\nimport {Literal, Term} from './literal'\n\n// class for parsing Units, Formulas, Clauses, Literals and Terms\nexport class UnitParser {\n\n\tstatic parsePreprocessingUnit(string: string): Unit {\n\t\t// heuristic to determine whether unit is a clause:\n\t\t// if unit only contains certain symbols, it has to be a clause\n\t\t// otherwise, treat it as a formula.\n\t\tconst symbolsAllowedInClauses = /^[a-zA-Z0-9()=,~!$ |']+$/;\n\t\tlet isClause = string.match(symbolsAllowedInClauses);\n\t\n\t\tif(isClause) {\n\t\t  return UnitParser.parseClause(string);\n\t\t} else {\n\t\t  return new Formula(string);\n\t\t}\n\t}\n\n\tstatic parseClause(string: string): Clause {\n\t\tif(string === \"$false\") {\n\t\t\treturn new Clause([], [], [], []); // empty clause\n\t\t}\n\n\t\tconst literals = this.parseLiterals(string);\n\t\treturn new Clause(literals, [], Array.from(literals), []);\n\t}\n\n\tstatic parseLiterals(string: string): Array<Literal> {\n\t\tconst literalStrings = string.split(\" | \");\n\t\tconst literals = new Array<Literal>();\n\t\tfor (let i = 0; i < literalStrings.length; i++) {\n\t\t\tliterals.push(UnitParser.parseLiteral(literalStrings[i]));\n\t\t}\n\t\treturn literals;\n\t}\n\n\tstatic parseLiteral(string: string): Literal {\n\t\t// need to handle equality separately, since it is written in infix-notation\n\t\t// all other predicates are written in prefix-notation\n\t\tlet equalityPosition = string.search(\"=\");\n\t\tif(equalityPosition !== -1)\n\t\t{\n\t\t\t// Vampire's printing of FOOL-formulas is quite hacky,\n\t\t\t// in particular FOOL-equalities always occur inside brackets, even for top-level literals\n\t\t\t// where the brackets are unnecessary\n\t\t\tif(string[0] === \"(\") {\n\t\t\t\tassert(string[string.length - 1] === \")\");\n\t\t\t\tstring = string.substring(1, string.length - 1);\n\t\t\t\tassert(equalityPosition > 0);\n\t\t\t\tequalityPosition -= 1;\n\t\t\t}\n\t\t\tif(string[equalityPosition - 1] === \"!\") {\n\t\t\t\tassert(string[equalityPosition - 2] === \" \", `negated equality not surrounded by spaces in string ${string}`);\n\t\t\t\tassert(string[equalityPosition + 1] === \" \", `negated equality not surrounded by spaces in string ${string}`);\n\t\t\t\tconst lhsString = string.substring(0, equalityPosition - 2);\n\t\t\t\tconst rhsString = string.substring(equalityPosition + 2, string.length);\n\t\t\t\tconst lhs = UnitParser.parseTerm(lhsString);\n\t\t\t\tconst rhs = UnitParser.parseTerm(rhsString);\n\t\t\t\treturn new Literal(\"=\", [lhs, rhs], true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tassert(string[equalityPosition - 1] === \" \", `equality not surrounded by spaces in string ${string}`);\n\t\t\t\tassert(string[equalityPosition + 1] === \" \", `equality not surrounded by spaces in string ${string}`);\n\t\t\t\tconst lhsString = string.substring(0, equalityPosition - 1);\n\t\t\t\tconst rhsString = string.substring(equalityPosition + 2, string.length);\n\t\t\t\tconst lhs = UnitParser.parseTerm(lhsString);\n\t\t\t\tconst rhs = UnitParser.parseTerm(rhsString);\n\t\t\t\t\n\t\t\t\treturn new Literal(\"=\", [lhs, rhs], false);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst negated = (string[0] === \"~\");\n\t\t\tconst atomString = negated ? string.substring(1) : string;\n\n\t\t\t// parse atom as term first and then convert it to literal\n\t\t\tconst literalTerm = UnitParser.parseTerm(atomString);\n\t\t\treturn new Literal(literalTerm.name, literalTerm.args, negated);\n\t\t}\n\t}\n\n\tstatic parseTerm(string:string): Term {\n\t\t// Part 1: lex tokens\n\t\tlet tokens: string[] = [];\n\t\tlet stringPos = 0;\n\t\twhile(stringPos < string.length) {\n\t\t\tconst char = string[stringPos];\n\t\t\t\n\t\t\tif (char === \"(\" || char === \")\" || char === \",\") {\n\t\t\t\ttokens.push(char);\n\t\t\t\tstringPos = stringPos + 1;\n\t\t\t} else {\n\t\t\t\tlet tokenEnd = stringPos;\n\t\t\t\twhile(tokenEnd < string.length \n\t\t\t\t\t&& string[tokenEnd] !== \"(\" \n\t\t\t\t\t&& string[tokenEnd] !== \")\" \n\t\t\t\t\t&& string[tokenEnd] !== \",\") {\n\t\t\t\t\ttokenEnd = tokenEnd + 1;\n\t\t\t\t}\n\t\t\t\ttokens.push(string.substring(stringPos,tokenEnd));\n\t\t\t\tstringPos = tokenEnd;\n\t\t\t}\n\t\t}\n\n\t\t// Part 2: add brackets after each string token which is not succeeded by brackets (that is, for each constant)\n\t\tfor (let i = 0; i < tokens.length; i++) {\n\t\t\tconst token = tokens[i];\n\t\t\tif(token !== \"(\" && token !== \")\" && token !== \",\"){\n\t\t\t\tif(i+1 === tokens.length || tokens[i+1] !== \"(\") {\n\t\t\t\t\ttokens.splice(i+1,0,\"(\");\n\t\t\t\t\ttokens.splice(i+2,0,\")\");\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\t// Part 3: parse token array\n\t\tlet stack: Array<Array<string|Term>> = [[]];\n\n\t\tfor (let pos = 0; pos < tokens.length; pos++) {\n\t\t\tconst token = tokens[pos];\n\n\t\t\tif(token !== \"(\" && token !== \")\" && token !== \",\")\n\t\t\t{\n\t\t\t\tstack[stack.length - 1].push(token);\n\t\t\t} \n\t\t\telse if (token === \"(\") \n\t\t\t{\n\t\t\t\tstack.push([]);\n\t\t\t}\n\t\t\telse if (token === \")\") \n\t\t\t{\n\t\t\t\tconst args = stack.pop() as Array<string | Term>;\n\t\t\t\tconst name = stack[stack.length - 1].pop();\n\t\t\t\tconst f = new Term(name as string, args as Array<Term>);\n\t\t\t\tstack[stack.length - 1].push(f);\n\t\t\t}\n\t\t}\n\n\t\tassert(stack.length === 1, \"invar violated for string: \" + string);\n\t\t// assert(stack[0].length === 1, \"invar violated for string:\" + string + \":\");\n\t\treturn stack[0][0] as Term;\n\t}\n}","\nimport { assert } from \"./util\";\nimport { Dag } from \"./dag\";\nimport SatNode from \"./sat-node\";\n\n// iterator for traversing DAG, where each node is visited only after all parents are visited\n// implements standard iterative depth-first postorder traversal\nexport class DFPostOrderTraversal {\n\t\n\treadonly dag: Dag;\n\ttodo: Array<number>;\n\tvisited: Set<number>;\n\t\n\tconstructor(dag: Dag) {\n\t\tthis.dag = dag;\n\t\tthis.todo = Array.from(dag.leaves);\n\t\tthis.visited = new Set();\n\t}\n\n\thasNext(): boolean {\n\t\twhile (this.todo.length > 0) {\n\t\t\tconst last = this.todo[this.todo.length - 1];\n\t\t\tif (this.visited.has(last)) {\n\t\t\t\tthis.todo.pop();\n\t\t\t} else {\n\t\t\t\t// there exists at least one unvisited node\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// returns the next node (the actual node, not its id) for traversal\n\t// note: only call this method after checking for has_next\n\tgetNext(): SatNode {\n\t\twhile (this.todo.length > 0) {\n\t\t\tconst currentId = this.todo[this.todo.length - 1];\n\t\t\tconst currentNode = this.dag.get(currentId);\n\n\t\t\t// if we haven't already visited the current unit\n\t\t\tif (!this.visited.has(currentId)) {\n\t\t\t\tlet existsUnvisitedParent = false;\n\t\t\t\t\n\t\t\t\t// add unprocessed parents to stack for DFS.\n\t\t\t\t// If there is at least one unprocessed parent, don't compute the result\n\t\t\t\t// for current_id now, but wait until those unprocessed parents are processed.\n\t\t\t\tfor (const parentId of currentNode.parents) {\n\t\t\t\t\t// if we haven't visited the parent yet\n\t\t\t\t\tif (! this.visited.has(parentId)) {\n\t\t\t\t\t\t// add it to the stack\n\t\t\t\t\t\tthis.todo.push(parentId);\n\t\t\t\t\t\texistsUnvisitedParent = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if we already visited all parents, we can visit the node too\n\t\t\t\tif (!existsUnvisitedParent) {\n\t\t\t\t\tthis.visited.add(currentId);\n\t\t\t\t\tthis.todo.pop();\n\t\t\t\t\treturn currentNode;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.todo.pop();\n\t\t\t}\n\t\t}\n\t\tassert(false, \"We have already iterated through all the inferences, so getNext() should not been called\");\n\t\treturn null as unknown as SatNode;\n\t}\n}\n\n// iterator for traversing DAG, where each node is visited before any parent node is visited\n// implemented as reversed postorder traversal\nexport class ReversePostOrderTraversal {\n\tpostOrder: Array<SatNode>;\n\n\tconstructor(dag: Dag) {\n\t\t// compute post order and save result in postOrder\n\t\tconst it = new DFPostOrderTraversal(dag);\n\t\tthis.postOrder = [];\n\t\twhile (it.hasNext()) {\n\t\t\tthis.postOrder.push(it.getNext() as SatNode);\n\t\t}\n\t}\n\n\thasNext(): boolean {\n\t\treturn this.postOrder.length > 0;\n\t}\n\n\tgetNext(): SatNode {\n\t\tassert(this.hasNext(), \"We have already iterated through all the inferences, so getNext() should not have been called\");\n\t\treturn this.postOrder.pop() as SatNode;\n\t}\n\n}","import { Literal, Term } from \"./literal\";\nimport { assert } from \"./util\";\n\nexport type Substitution = Map<string, Term>;\n\nexport function literalsMatch(literal1: Literal, literal2: Literal, allowSubstitutions: boolean) {\n\tif (allowSubstitutions) {\n\t\treturn isSubstitution(literal1, literal2);\n\t} else {\n\t\treturn isEqual(literal1, literal2);\n\t}\n}\n\nexport function isEqual(literal1: Literal, literal2: Literal): boolean {\n\tif (literal1.name !== literal2.name || literal1.negated !== literal2.negated || literal1.args.length !== literal2.args.length) {\n\t\treturn false;\n\t}\n\tlet success = true;\n\tfor (let i = 0; i < literal1.args.length; i++) {\n\t\tconst arg1 = literal1.args[i];\n\t\tconst arg2 = literal2.args[i];\n\t\tif (!termsAreEqual(arg1,arg2)) {\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// support commutativity of equalities\n\tif (!success && literal1.name === \"=\") {\n\t\tassert(literal1.args.length === 2);\n\t\tsuccess = \n\t\t\ttermsAreEqual(literal1.args[0], literal2.args[1]) &&\n\t\t\ttermsAreEqual(literal1.args[1], literal2.args[0]);\n\t}\n\n\treturn success;\n}\n\nexport function termsAreEqual(f1: Term, f2: Term) {\n\tif (f1.name !== f2.name || f1.args.length !== f2.args.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < f1.args.length; i++) {\n\t\tconst arg1 = f1.args[i];\n\t\tconst arg2 = f2.args[i];\n\t\tif (!termsAreEqual(arg1,arg2)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// returns true if literal1 can be obtained from literal2 by substitution\nexport function isSubstitution(literal1: Literal, literal2: Literal): boolean {\n\tif (literal1.name !== literal2.name || literal1.negated !== literal2.negated || literal1.args.length !== literal2.args.length) {\n\t\treturn false;\n\t}\n\tlet success = true;\n\tconst substitution = new Map<string, Term>();\n\tfor (let i = 0; i < literal1.args.length; i++) {\n\t\tconst arg1 = literal1.args[i];\n\t\tconst arg2 = literal2.args[i];\n\t\tsuccess = computeSubstitution(arg1,arg2, substitution);\n\t\tif (!success) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// support commutativity of equalities\n\tif (!success && literal1.name === \"=\") {\n\t\tassert(literal1.args.length === 2);\n\t\tconst substitutionEq = new Map<string, Term>();\n\t\tsuccess = computeSubstitution(literal1.args[0], literal2.args[1], substitutionEq);\n\t\tif (success) {\n\t\t\tsuccess = computeSubstitution(literal1.args[1], literal2.args[0], substitutionEq);\n\t\t}\n\t}\n\t\n\treturn success;\n}\n\n// compute whether f1 can be obtained from f2 using a substitution compatible with substitution\n// if yes, returns true and updates the substitution\n// if no, returns false, and there are no guarantees on the state of substitution\nexport function computeSubstitution(f1: Term, f2: Term, substitution: Substitution): boolean {\n\tif (f1.name === f2.name && f1.args.length === f2.args.length) {\n\t\tfor (let i = 0; i < f1.args.length; i++) {\n\t\t\tconst arg1 = f1.args[i];\n\t\t\tconst arg2 = f2.args[i];\n\t\t\tconst success = computeSubstitution(arg1,arg2, substitution);\n\t\t\tif (!success) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t} else if (f2.isVariable) {\n\t\tconst substitutedVariable = substitution.get(f2.name);\n\t\tif (substitutedVariable === undefined) {\n\t\t\tsubstitution.set(f2.name, f1);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn computeSubstitution(f1, substitutedVariable, substitution);\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}","import SatNode from './sat-node';\nimport { assert } from './util';\nimport { UnitParser } from './unit-parser';\nimport { ReversePostOrderTraversal, DFPostOrderTraversal } from \"./traversal\";\nimport { Clause } from './unit';\nimport { literalsMatch } from './substitution';\nimport { Literal } from './literal';\n\nexport class ParsedLine {\n  readonly type: \"preprocessing\" | \"new\" | \"active\" | \"forward reduce\" | \"backward reduce\" | \"replaced by\" | \"using\";\n  readonly id: number;\n  readonly unitString: string;\n  readonly inferenceRule: string;\n  parents: Array<number>;\n  readonly statistics: Map<any, any>; \n\n  constructor(type: \"preprocessing\" | \"new\" | \"active\" | \"forward reduce\" | \"backward reduce\" | \"replaced by\" | \"using\", id: number, unitString: string, inferenceRule: string, parents: Array<number>, statistics: Map<any, any>) {\n    this.type = type;\n    this.id = id;\n    this.unitString = unitString;\n    this.inferenceRule = inferenceRule;\n    this.parents = parents;\n    this.statistics = statistics;\n  }\n}\n\nexport type SatNodeStyle = \"passive\" | \"deleted\" | \"activated\" | \"activated-deleted\" | \"boundary\" | \"boundary-deleted\" | \"preprocessing\" | \"preprocessing-deleted\" | \"theory-axiom\" | 'theory-axiom-deleted' | \"conjecture\";\nexport class Dag {\n\n  // TODO: it seems that the result of Graphviz depends on the order of node- and edge declarations.\n  //       the order of these declarations depends on the order in which the nodes occur in the nodes-Map.\n  //       therefore it could make sense to normalize the order of nodes in the nodes-Map at construction time of the Dag.\n  readonly nodes: Map<number,SatNode>;\n  readonly leaves: Set<number>;\n  readonly mergeMap: Map<number, Array<number>> | null;\n  \n  // invar: if isPassiveDag, then styleMap !== null\n  readonly isPassiveDag: boolean;\n  readonly styleMap: Map<number, SatNodeStyle> | null;\n  readonly activeNodeId: number | null; // the id of the node for which passiveDag was computed\n\n  constructor(nodes: Map<number,SatNode>, mergeMap: Map<number, Array<number>> | null = null, isPassiveDag: boolean = false, styleMap: Map<number, SatNodeStyle> | null = null, activeNodeId: number | null = null) {\n    this.nodes = nodes;\n    this.mergeMap = mergeMap;\n\n    assert(!isPassiveDag || styleMap !== null);\n    assert(!isPassiveDag || activeNodeId !== null);\n    assert(!isPassiveDag || nodes.has(activeNodeId as number));\n\n    this.isPassiveDag = isPassiveDag;\n    this.styleMap = styleMap;\n    this.activeNodeId = activeNodeId;\n\n    // sanity check: key and id of node need to match\n    for (const [nodeId, node] of nodes) {\n      assert(nodeId === node.id, `key ${nodeId} and id ${node.id} of node ${node} don't match!`);\n    }\n\n    // sanity check: each parentId needs to occur in the derivation as node\n    for (const [nodeId, node] of nodes) {\n      for (const parentId of node.parents) {\n        assert(nodes.has(parentId), `node ${nodeId} has parent ${parentId} which does not occur as node in the dag!`);\n      }\n    }\n    // compute leaves\n    const leaves: Set<number> = new Set();\n    const nonLeaves: Set<number> = new Set();\n    \n    for (const node of nodes.values()) {\n      for (const parentId of node.parents) {\n        nonLeaves.add(parentId);\n      }\n    }\n\n    for (const nodeId of nodes.keys()) {\n      if(!nonLeaves.has(nodeId)) {\n        leaves.add(nodeId);\n      }\n    }\n\n    this.leaves = leaves;\n  }\n\n  get(nodeId: number): SatNode {\n    const node = this.nodes.get(nodeId);\n    assert(node !== undefined, \"node doesn't occur in Dag\");\n    return node as SatNode;\n  }\n\n  maximalActiveTime(): number {\n    let max = 0;\n    for (const node of this.nodes.values()) {\n      if (node.activeTime !== null && node.activeTime > max) {\n        max = node.activeTime;\n      }\n    }\n    return max;\n  }\n\n  isEmpty(): boolean {\n    return this.nodes.size === 0;\n  }\n\n  getChildren(nodeId: number): Array<number> {\n    if(!this.nodes.has(nodeId)) {\n      assert(false, \"Node with id \" + nodeId + \" does not occur in Dag\");\n    }\n\n    const children = new Array<number>();\n    for (const node of this.nodes.values()) {\n      for (const parentId of node.parents) {\n        if (parentId === nodeId) {\n          children.push(node.id);\n        }\n      }\n    }\n    return children;\n  }\n\n  numberOfTransitiveActivatedChildren(nodeId: number, currentTime: number) {\n    let counter = 0;\n\n        // use new set to avoid mutating relevantIds\n    const transitiveChildrenIds = new Set<number>([nodeId]);\n\n    // add all transitive children of ids in transitiveChildren to transitiveChildren\n    const iterator = new DFPostOrderTraversal(this);\n    while (iterator.hasNext()) {\n      let currentNode = iterator.getNext();\n\n      // check if currentNode occurs in transitiveChildren or\n      // has a parent which occurs in transitiveChildren\n      let existsRelevantParent = false;\n      for (const parentId of currentNode.parents) {\n        if (transitiveChildrenIds.has(parentId)) {\n          existsRelevantParent = true;\n          break;\n        }\n      }\n      const isRelevant = existsRelevantParent || transitiveChildrenIds.has(currentNode.id);\n      const alreadyGenerated = currentNode.isFromPreprocessing || (currentNode.newTime !== null && currentNode.newTime <= currentTime);\n      if (isRelevant && alreadyGenerated) {\n        // add its id to the set of relevant ids\n        transitiveChildrenIds.add(currentNode.id);\n\n        const alreadyActivated = currentNode.activeTime !== null && currentNode.activeTime <= currentTime;\n        if (currentNode.id !== nodeId && alreadyActivated) {\n          counter = counter + 1;\n        }\n      }\n    }\n\n    return counter;\n  }\n\n  /* we can partition all nodes of the derivation into three sets\n   * 1) inputNodes: the nodes given to Vampire's preprocessing as input\n   * 2) preprocessingResultNodes: the nodes remaining at the end of Vampire's preprocessing, (which are then used as input for saturation)\n   * 3) otherNodes: the nodes generated by saturation\n   *\n   * this function decides for a given node whether it should be treated as input node, using the following idea:\n   * 1) input nodes occur before saturation is started and are therefore tagged with \"isFromPreprocessing\"\n   * 2) preprocessingResultNodes are used as input for saturation, so their newTime is set\n   */ \n  nodeIsInputNode(nodeId: number): boolean {\n    const node = this.get(nodeId);\n\n    if (!node.isFromPreprocessing) {\n      return false;\n    }\n    if(node.newTime !== null) {\n      return false;\n    }\n    return true;\n  }\n\n  // heuristics to determine whether a node is a theory axiom\n  // note: Vampire uses \"theory axiom\" for some of the internal theory axioms\n  // the internal theory axioms added for term algebras do not follow this convention\n  // even more, one of those term algebra axioms (the exhaustiveness axiom) is added as formula (in contrast to all other axioms which are added as clauses)\n  // in particular, the exhaustiveness axiom consists of a formula labelled \"term algebras exhaustiveness\" and a child node which is labelled cnf transformation\n  nodeIsTheoryAxiom(nodeId: number): boolean {\n    const node = this.get(nodeId);\n\n    if (!node.isFromPreprocessing) {\n      return false;\n    }\n    if (node.inferenceRule === \"theory axiom\" || \n        node.inferenceRule === \"term algebras injectivity\" || \n        node.inferenceRule === \"term algebras distinctness\" ||\n        node.inferenceRule === \"term algebras exhaustiveness\" ||\n        (node.parents.length === 1 && this.get(node.parents[0]).inferenceRule ===  \"term algebras exhaustiveness\")) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // either 1) create a new dag given an array of parsed lines and no existing dag,\n  // or     2) extend an existing dag with an array of parsed lines\n  // In case 2) we assume that all the parsedLines are generated during Saturation, i.e. no additional preprocessing occurs.\n  static fromParsedLines(parsedLines: Array<ParsedLine>, existingDag: Dag | null): Dag {\n    const nodes = (existingDag === null) ? new Map<number, SatNode>() : new Map<number, SatNode>(existingDag.nodes);\n\n    let currentNode: SatNode | null = null;\n    let currentTime = (existingDag === null) ? 0 : existingDag.maximalActiveTime();\n\n    let emptyClauseNode: SatNode | null = null;\n\n    for (const line of parsedLines) {\n\n      // some preprocessing nodes have potentially been merged, and there could be parsedLines which still reference the ids of these nodes.\n      // we therefore convert those ids using the merge-map\n      if (existingDag !== null && existingDag.mergeMap !== null) {\n        assert(existingDag.mergeMap.get(line.id) === undefined, `found line with id ${line.id} of node deleted during merge of preprocessing nodes!`);\n        const parentsAfterMerge = new Array<number>();\n        for (const parentId of line.parents) {\n          const mergedParentsOrUndefined = existingDag.mergeMap.get(parentId);\n          if (mergedParentsOrUndefined !== undefined) {\n            parentsAfterMerge.push(...mergedParentsOrUndefined);\n          } else {\n            parentsAfterMerge.push(parentId);\n          }\n        }\n        line.parents = parentsAfterMerge;\n      }\n\n      if (line.type === \"preprocessing\") {\n        // line represents the generation of a clause during preprocessing\n        assert(existingDag === null, \"no new preprocessing lines should occur while extending existing dag with new nodes from saturation\")\n        assert(!nodes.has(line.id), \"each clause must be generated by preprocessing only once\");\n        const unit = UnitParser.parsePreprocessingUnit(line.unitString);\n\n        // hack: Vampire treats a conjecture as input clause, followed by an inference, which transforms the input into a negated conjecture.\n        // we want only the negated conjecture, so we delete the (single) premise of such an inference if it occurs.\n        if (line.inferenceRule === \"negated conjecture\") {\n          assert(line.parents.length === 1);\n          // remove parent from nodes\n          const parent = nodes.get(line.parents[0]);\n          assert(parent !== undefined);\n          assert((parent as SatNode).inferenceRule === \"input\");\n          const success = nodes.delete(line.parents[0]);\n          assert(success);\n          // update parents of current line\n          line.parents = [];\n        }\n\n        currentNode = new SatNode(line.id, unit, line.inferenceRule, line.parents, line.statistics, true, null, null, null, [], false);\n        nodes.set(currentNode.id, currentNode);\n      }\n      else if (line.type === \"new\") {\n        if (!nodes.has(line.id)) {\n          // line represents the generation of a new clause (which wasn't generated in preprocessing) during saturation\n          \n          // create new node\n          const unit = UnitParser.parseClause(line.unitString);\n          currentNode = new SatNode(line.id, unit, line.inferenceRule, line.parents, line.statistics, false, currentTime, null, null, [], false);\n          nodes.set(currentNode.id, currentNode);\n\n          if(line.unitString === \"$false\") {\n            emptyClauseNode = currentNode;\n          }\n        } else {\n          // line represents a final clause from preprocessing, which now is added into saturation\n          assert(existingDag === null, \"no new final clauses from preprocessing should occur during the extension of an existing dag\")\n          currentNode = nodes.get(line.id) as SatNode;\n          assert(currentNode.isFromPreprocessing, \"a newly added clause can only already exist if it was generated during preprocessing\");\n          assert(line.inferenceRule === currentNode.inferenceRule, \"inference rule differs between line and existing node\");\n          const unit = UnitParser.parseClause(line.unitString);\n          currentNode.unit = unit;\n          currentNode.newTime = currentTime;\n        }\n      }\n      else if (line.type === \"active\") {\n        // line represents the addition of that clause to active\n        // an active-event gives us the following information about a clause:\n        // - the node was activated at the current time.\n        // - the number of selected literals in the clause, saved in the statistics-object (\"nSel\") of the active-event\n        // - the literals in the clause which are selected: the clause of the active-event satisfies the invariant that the selected literals occur first.\n        // - some statistics about the clause and its derivation, saved in the statistics-object of the active-event\n        assert(nodes.has(line.id), `Found clause with id ${line.id}, which was added to active, but wasn't added to new before. Maybe you forgot to output the new clauses?`);\n        currentNode = nodes.get(line.id) as SatNode;\n        assert(line.id === currentNode.id, \"id differs between line and existing node\");\n        assert(line.inferenceRule === currentNode.inferenceRule, \"inference rule differs between line and existing node\");\n        assert(line.parents.length === currentNode.parents.length, \"number of parents differs between line and existing node\");\n        for (let i = 0; i < line.parents.length; i++) {\n          assert(line.parents[i] === currentNode.parents[i], `line and node differ on parent ${i}, which is ${line.parents[i]} resp. ${currentNode.parents[i]}.`);\n        }\n        assert(currentNode.newTime !== null, \"for each event [SA] active ... there has to be an earlier event of the form [SA] new ... with the same clause!\")\n        assert(currentNode.activeTime === null, \"there must only be 1 event of the form [SA] active ... for each clause\");\n        assert(currentNode.unit.type === \"Clause\");\n        const clause = currentNode.unit as Clause;\n        assert(clause.literalsNewEvent !== null);\n\n        // note that the literals in literalsAfterActivation potentially occur in a different order than in clause,\n        // since literalsAfterActivation satisfies the invariant that the selected literals occur first.\n        const literalsAfterActivation = UnitParser.parseLiterals(line.unitString);\n\n        // mpa each literal to a literal in the existing clause\n        // for each selected literal also mark the literal in the existing clause as selected.\n        const nSel = line.statistics.get(\"nSel\");\n        assert(nSel !== undefined && nSel !== null);\n\n        const existingLiteralsActiveOrder = new Array<Literal>();\n        for (let i = 0; i < literalsAfterActivation.length; i++) {\n          const literal = literalsAfterActivation[i];\n          let foundMatch = false;\n          for (const existingLiteral of clause.literalsNewEvent!) {\n            if (literalsMatch(literal, existingLiteral, false)) {\n              existingLiteralsActiveOrder.push(existingLiteral);\n              foundMatch = true;\n              if (i < nSel) {\n                existingLiteral.isSelected = true;\n              }\n              break;\n            }\n          }\n          assert(foundMatch);\n        }\n        clause.literalsActiveEvent = existingLiteralsActiveOrder;\n\n        currentTime = currentTime + 1;\n        currentNode.activeTime = currentTime;\n        currentNode.statistics = line.statistics\n      }\n      else if (line.type === \"forward reduce\" || line.type === \"backward reduce\") {\n        // line represents the removal of a clause from saturation\n        assert(nodes.has(line.id), `Found clause with id ${line.id}, which was deleted, but wasn't added as new before. Maybe you forgot to output the new clauses?`);\n        currentNode = nodes.get(line.id) as SatNode;\n        currentNode.deletionTime = currentTime;\n      }\n      else if (line.type === \"replaced by\" || line.type === \"using\") {\n        // line represents one of the clauses which allowed to remove the clause represented by currentNode from saturation\n        assert(currentNode !== null, \"invar\");\n        (currentNode as SatNode).deletionParents.push(line.id);\n      }\n      else {\n        assert(false, `invalid line: ${line.unitString}`);\n      }\n    }\n\n    // hack: pretend that empty clause was added to passive and then activated\n    // note that this can only be done after all lines are parsed, since a new-event with the empty clause often triggers a deletion-event\n    if (emptyClauseNode !== null) {\n      currentTime = currentTime + 1;\n      emptyClauseNode.activeTime = currentTime;\n      nodes.set(emptyClauseNode.id, emptyClauseNode);\n    }\n\n    const extendedDag = new Dag(nodes, existingDag === null ? null : existingDag.mergeMap);\n\n    return extendedDag;\n  }\n\n  // note: includes nodes which have been activated, but have also been deleted\n  computeActiveNodes(currentTime: number) : Set<number> {\n    const activeNodeIds = new Set<number>();\n    for (const [nodeId, node] of this.nodes) {\n      const nodeIsActive = (node.activeTime !== null && node.activeTime <= currentTime);\n      if (nodeIsActive) {\n        activeNodeIds.add(nodeId);\n      }\n    }\n\n    return activeNodeIds;\n  }\n\n  // Definition: the active dag contains all nodes which occur in the derivation of an already activated node, and all preprocessing nodes\n  computeNodesInActiveDag(currentTime: number) : Set<number> {\n    const nodeIds = this.computeActiveNodes(currentTime);\n\n\t  // add all transitive parents of nodeIds to nodeIds\n\t  const iterator = new ReversePostOrderTraversal(this);\n\t  while (iterator.hasNext()) {\n\t\t  const currentNode = iterator.getNext();\n      const currentNodeId = currentNode.id;\n    \n      if (nodeIds.has(currentNodeId)) {\n        for (const parentId of currentNode.parents) {\n          nodeIds.add(parentId);\n        }\n      }    \n    }\n\n    // add all preprocessing nodes\n    for (const node of this.nodes.values()) {\n      if (node.isFromPreprocessing) {\n        nodeIds.add(node.id);\n      }\n    }\n    \n    return nodeIds;\n  }\n\n  isRefutation(): boolean {\n    for (const node of this.nodes.values()) {\n      if(node.unit.type === \"Clause\" && \n          (node.unit as Clause).premiseLiterals.length === 0 && \n          (node.unit as Clause).conclusionLiterals.length === 0) {\n            return true;\n          }\n    }\n    return false;\n  }\n}","import { assert } from \"./util\";\nimport { Dag, SatNodeStyle } from \"./dag\";\nimport SatNode from \"./sat-node\";\nimport { ReversePostOrderTraversal, DFPostOrderTraversal } from \"./traversal\";\n\n// returns a new dag containing only the nodes which either\n// have an id in relevantIds or\n// are transitive parents of a node with id in relevantIds\nexport function filterNonParents(dag: Dag, relevantIds: Set<number>) {\n\t// use new set to avoid mutating relevantIds\n\tconst transitiveParentIds = new Set(relevantIds);\n\n\t// need to compute remaining nodes\n\tconst remainingNodes = new Map<number, SatNode>();\n\n\t// add all transitive parents of transitive_parents to transitiveParents\n\tconst iterator = new ReversePostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tconst currentNode = iterator.getNext();\n\t\tconst currentNodeId = currentNode.id;\n\n\t\t// if currentNode is relevant\n\t\tif (transitiveParentIds.has(currentNodeId)) {\n\t\t\t\n\t\t\t// mark parents relevant\n\t\t\tcurrentNode.parents.forEach(parentId => transitiveParentIds.add(parentId));\n\n\t\t\t// add node to remainingNodes\n\t\t\tremainingNodes.set(currentNodeId,currentNode);\n\t\t}\n\t}\n\n\t// create deep copy of nodes\n\t// needed so that layout computation for the transformed dag does not overwrite the layout of the original dag\n\tconst remainingNodesDeepCopy = new Map<number, SatNode>();\n\tfor (const [nodeId,node] of remainingNodes) {\n\t\tremainingNodesDeepCopy.set(nodeId, node.copy());\n\t}\n\treturn new Dag(remainingNodesDeepCopy);\n}\n\n// returns a new dag containing only the nodes which either\n// have an id in relevant_ids or\n// are transitive children of a node with id in relevant_ids.\n// additionally keeps boundary nodes\nexport function filterNonConsequences(dag: Dag, relevantIds: Set<number>) {\n\t// use new set to avoid mutating relevantIds\n\tconst transitiveChildrenIds = new Set<number>(relevantIds);\n\n\t// need to compute remaining nodes\n\tconst remainingNodes = new Map<number, SatNode>();\n\n\t// add all transitive children of ids in transitiveChildren to transitiveChildren\n\tconst iterator = new DFPostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tlet currentNode = iterator.getNext();\n\n\t\t// check if currentNode occurs in transitiveChildren or\n\t\t// has a parent which occurs in transitiveChildren\n\t\tlet existsRelevantParent = false;\n\t\tfor (const parentId of currentNode.parents) {\n\t\t\tif (transitiveChildrenIds.has(parentId)) {\n\t\t\t\texistsRelevantParent = true;\n\t\t\t}\n\t\t}\n\t\tconst isRelevant = transitiveChildrenIds.has(currentNode.id) || existsRelevantParent;\n\n\t\tif (isRelevant) {\n\t\t\t// add its id to the set of relevant ids\n\t\t\ttransitiveChildrenIds.add(currentNode.id);\n\n\t\t\t// if there exists at least one relevant parent, \n\t\t\tif (existsRelevantParent) {\n\t\t\t\t// introduce a boundary nodes for all nonrelevant parents\n\t\t\t\tfor (const parentId of currentNode.parents) {\n\t\t\t\t\tif (!transitiveChildrenIds.has(parentId)) {\n\t\t\t\t\t\tconst boundaryNode = createBoundaryNode(dag.get(parentId));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// boundaryNode has currentNode as child and is therefore no leaf\n\t\t\t\t\t\tassert(!dag.leaves.has(boundaryNode.id), \"invar violated. Boundary nodes should only occur as parents of nodes\");\n\t\t\t\t\t\tremainingNodes.set(boundaryNode.id, boundaryNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// otherwise ignore all parents: introduce a copy of the node which has no parents\n\t\t\t\tcurrentNode = createBoundaryNode(currentNode);\n\t\t\t}\n\n\t\t\t// add currentNode to remainingNodes\n\t\t\tremainingNodes.set(currentNode.id, currentNode);\n\t\t} \n\t}\n\n\t// create deep copy of nodes\n\t// needed so that layout computation for the transformed dag does not overwrite the layout of the original dag\n\tconst remainingNodesDeepCopy = new Map<number, SatNode>();\n\tfor (const [nodeId,node] of remainingNodes) {\n\t\tremainingNodesDeepCopy.set(nodeId, node.copy());\n\t}\n\treturn new Dag(remainingNodesDeepCopy);\n}\n\nfunction createBoundaryNode(node: SatNode): SatNode {\n\treturn new SatNode(node.id, node.unit, node.inferenceRule, [], node.statistics, node.isFromPreprocessing, node.newTime, node.activeTime, node.deletionTime, node.deletionParents, node.isBoundary);\n}\n\n// vampire performs preprocessing in multiple steps\n// we are only interested in\n// 1) the input-formulas (and axioms added by Vampire)\n// 2) the clauses resulting from them\n// We therefore merge together all preprocessing steps into single steps\n// from input-formulas/vapire-added-axioms to final-preprocessing-clauses\n// additionally remove all choice axiom parents, since we treat them as part of the background theory\nexport function mergePreprocessing(dag: Dag): Dag {\n\tconst nodes = new Map<number, SatNode>(dag.nodes);\n\tconst nodeIdsToRemove = new Set<number>(); // nodes which should be removed. note that we can't remove them upfront due to the fact that the derivation is a dag and not a tree\n\tconst mergeMap = new Map<number, Array<number>>(); // maps merged nodes to the replacing nodes, needed for extending the dag later\n\n\tconst postOrderTraversal = new DFPostOrderTraversal(dag);\n\twhile (postOrderTraversal.hasNext()) {\n\t\t// note: the ids are still valid, but the nodes may have been replaced by new node\n\t\tconst currentNodeId = postOrderTraversal.getNext().id;\n\t\tconst currentNode = nodes.get(currentNodeId) as SatNode;\n\n\t\t// if there is a preprocessing node n1 with a parent node n2 which has itself a parent node n3,\n\t\t// then replace n2 by n3 in the parents of n1 and add n2 to the nodes which should be removed\n\t\tif (currentNode.isFromPreprocessing) {\n\t\t\tconst updatedParents = new Array<number>();\n\t\t\tfor (const parentId of currentNode.parents) {\n\t\t\t\tconst parentNode = nodes.get(parentId) as SatNode;\n\t\t\t\tassert(parentNode.isFromPreprocessing, \"invariant violated\");\n\n\t\t\t\tif (parentNode.parents.length === 0) {\n\t\t\t\t\t// small optimization: remove choice axioms, which should not been added to the proof by Vampire in the first place\n\t\t\t\t\tif (parentNode.inferenceRule === \"choice axiom\") {\n\t\t\t\t\t\tnodeIdsToRemove.add(parentId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdatedParents.push(parentId);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (const parent2Id of parentNode.parents) {\n\t\t\t\t\t\tconst parent2Node = nodes.get(parent2Id) as SatNode;\n\t\t\t\t\t\tassert(parent2Node.isFromPreprocessing, \"invariant violated\");\n\t\t\t\t\t\tupdatedParents.push(parent2Id);\n\t\t\t\t\t}\n\t\t\t\t\tnodeIdsToRemove.add(parentId);\n\t\t\t\t\tmergeMap.set(parentId, parentNode.parents);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst updatedNode = new SatNode(currentNode.id, currentNode.unit, currentNode.inferenceRule, updatedParents, currentNode.statistics, currentNode.isFromPreprocessing, currentNode.newTime, currentNode.activeTime, currentNode.deletionTime, currentNode.deletionParents, currentNode.isBoundary);\n\t\t\tnodes.set(currentNodeId, updatedNode);\n\t\t}\n\t}\n\n\t// remove merged nodes\n\tfor (const nodeIdToRemove of nodeIdsToRemove) {\n\t\tconst success = nodes.delete(nodeIdToRemove);\n\t\tassert(success, \"invar violated\");\n\t}\n\n\treturn new Dag(nodes, mergeMap);\n}\n\n// preconditions:\n// - selectionIds contains only ids from nodes which either 1) have already been activated or 2) are final preprocessing clauses\n// - selectionIds must contain at least one element\nexport function passiveDagForSelection(dag: Dag, selectionIds: Array<number>, currentTime: number): Dag {\n\tassert(selectionIds.length > 0);\n\tconst selectionIdsSet = new Set(selectionIds);\n\n\t// Part 1: for each passive node n, we consider the transitive parents p_1,...p_k occuring in the activeDag, \n\t// such that for each parent p_i no other node inbetween n and p_i occurs in the activeDag. If selectionId \n\t// is a subset of {p_1,...,p_k}, then n is added to foundNodes\n\tconst foundNodes = new Set<number>();\n\n\tconst idToActiveDagParents = new Map<number, Set<number>>();\n\tconst iterator = new DFPostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tconst node = iterator.getNext();\n\t\tconst nodeId = node.id;\n\n\t\tconst activeDagParents = new Set<number>();\n\n\t\tconst nodeIsInActiveDag = ((node.activeTime !== null && node.activeTime <= currentTime) || node.isFromPreprocessing);\n\t\tif(nodeIsInActiveDag) {\n\t\t\tif (selectionIdsSet.has(nodeId)) {\n\t\t\t\tactiveDagParents.add(nodeId);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const parentId of node.parents) {\n\t\t\t\tconst activeDagParentsParent = idToActiveDagParents.get(parentId);\n\t\t\t\tassert(activeDagParentsParent !== undefined);\n\t\t\t\tfor (const activeDagParent of activeDagParentsParent!) {\n\t\t\t\t\tactiveDagParents.add(activeDagParent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if node is passive and each clause from selection occurs in activeDagParents, then add node to foundNodes\n\t\t\tconst nodeIsInPassive = ((node.newTime !== null && node.newTime <= currentTime) && !(node.activeTime !== null && node.activeTime <= currentTime) && !(node.deletionTime !== null && node.deletionTime <= currentTime));\n\t\t\tif (nodeIsInPassive) {\n\t\t\t\tif (activeDagParents.size === selectionIdsSet.size) {\n\t\t\t\t\tfoundNodes.add(nodeId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tidToActiveDagParents.set(nodeId, activeDagParents);\n\t}\n\t\n\t// Part 2:\n\t// we now know the set of passive nodes, so\n\t// - collect all nodes participating in the derivation of the passive nodes from nodes in the current activeDag\n\t// - compute for each such node its style\n\tconst passiveDagNodes = new Map<number, SatNode>();\n\tconst nodePartition = new Map<number, SatNodeStyle>();\n\n\tconst relevantNodes = new Set<number>(foundNodes);\n\n\t// additionally display each node from selection, even if no passive node is generated by the node\n\tfor (const nodeId of selectionIds) {\n\t\trelevantNodes.add(nodeId);\n\t}\n\n\tconst iterator2 = new ReversePostOrderTraversal(dag);\n\twhile (iterator2.hasNext()) {\n\t\tconst node = iterator2.getNext();\n\t\tconst nodeId = node.id;\n\n\t\tif (relevantNodes.has(nodeId)) {\n\t\t\tconst isDeleted = (node.deletionTime !== null && node.deletionTime <= currentTime);\n\n\t\t\t// compute whether the derivation should be extended with the parents of the node, and compute the style of the node\n\t\t\tlet isBoundary;\n\t\t\tlet style;\n\t\t\tif (foundNodes.has(nodeId)) {\n\t\t\t\tassert(!isDeleted);\n\t\t\t\tif (node.isFromPreprocessing) {\n\t\t\t\t\tisBoundary = true;\n\t\t\t\t\tstyle = \"passive\";\n\t\t\t\t} else {\n\t\t\t\t\tisBoundary = false;\n\t\t\t\t\tstyle = \"passive\";\n\t\t\t\t}\n\t\t\t} else if (dag.nodeIsTheoryAxiom(nodeId)) {\n\t\t\t\tisBoundary = true;\n\t\t\t\tstyle = isDeleted ? \"theory-axiom-deleted\" : \"theory-axiom\";\n\t\t\t} else if (node.isFromPreprocessing) {\n\t\t\t\tif (node.inferenceRule === \"negated conjecture\") {\n\t\t\t\t\tisBoundary = true;\n\t\t\t\t\tstyle = \"conjecture\";\n\t\t\t\t} else {\n\t\t\t\t\tisBoundary = true;\n\t\t\t\t\tstyle = isDeleted ? \"preprocessing-deleted\" : \"preprocessing\";\n\t\t\t\t}\n\t\t\t} else if (node.activeTime !== null && node.activeTime <= currentTime) {\n\t\t\t\tisBoundary = true;\n\t\t\t\tstyle = isDeleted ? \"activated-deleted\" : \"activated\";\n\t\t\t} else {\n\t\t\t\tisBoundary = false;\n\t\t\t\tstyle = \"deleted\";\n\t\t\t}\n\n\t\t\tif (isBoundary) {\n\t\t\t\tpassiveDagNodes.set(nodeId, createBoundaryNode(node));\n\t\t\t} else {\n\t\t\t\tpassiveDagNodes.set(nodeId, node.copy()); // copy node so that positioning passiveDag will not change positioning of original dag\n\t\t\t\tfor (const parent of node.parents) {\n\t\t\t\t\trelevantNodes.add(parent);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodePartition.set(nodeId, style);\n\t\t}\n\t}\n\n\tconst passiveDag = new Dag(passiveDagNodes, null, true, nodePartition, selectionIds[0]);\n\treturn passiveDag;\n}","import Viz from 'viz.js';\nimport {Module, render} from 'viz.js/full.render.js';\n\nexport async function runViz(dotString) {\n\tlet viz = new Viz({Module, render});\n\n\treturn viz\n\t\t.renderString(dotString, {format: 'plain'})\n\t\t.then((result) => {\n\t\treturn result;\n\t\t})\n\t\t.catch((error) => {\n\t\tviz = new Viz({Module, render});\n\t\tconsole.error(error);\n\t\t});\n};","import { assert } from '../model/util';\nimport { Dag } from '../model/dag';\nimport { runViz } from './callViz';\nimport SatNode from './sat-node';\n\nconst PLAIN_PATTERN = /^(\\d+) ([0-9.]+) ([0-9.]+).*$/g;\n\nexport class VizWrapper {\n\n  // first computes the positions for the nodes while ignoring the position given as parameter.\n  // then, all node positions are shifted by the same amount so that one of the nodes \n  // occurs closely under the position given as parameter\n  static async layoutNodesAtPosition(nodes: Map<number, SatNode>, position: [number, number]) {\n    // 1) layout new nodes while ignoring existing nodes\n    await VizWrapper.layoutNodes(nodes);\n\n    // 2) find a source node of the dag of newly generated nodes\n    let sourceNode: SatNode | null = null;\n    for (const node of nodes.values()) {\n      let isSourceNode = true;\n      for (const parentId of node.parents) {\n        if (nodes.has(parentId)) {\n          isSourceNode = false;\n          break;\n        }\n      }\n      if (isSourceNode) {\n        sourceNode = node;\n        break;\n      }\n    }\n    assert(sourceNode !== null);\n    assert((sourceNode as SatNode).position !== null);\n\n    // 3) shift subgraph of newly generated nodes, so that the source node of the subgraph\n    //    is shifted to a position closely under the position indicated by the positioning hint.\n    const [posSelectedX, posSelectedY] = position;\n    const [posSourceX, posSourceY] = (sourceNode as SatNode).position as [number, number];\n    const deltaX = posSelectedX-posSourceX;\n    const deltaY = (posSelectedY - posSourceY) - 1;\n    for (const node of nodes.values()) {\n      assert(node.position != null);\n      const position = node.position as [number, number];\n      node.position = [position[0] + deltaX, position[1] + deltaY];\n    }\n  }\n\n  static async layoutDag(dag: Dag, onlyActiveDag: boolean) {\n    // generate dot string\n    const dotString = VizWrapper.dagToDotString(dag, onlyActiveDag);\n    \n    // use viz to compute layout for dag given as dotstring\n    // note that viz returns the layout as a string\n    const layoutString = await runViz(dotString);\n\n    // parse the layout string into array of network-nodes\n    VizWrapper.parseLayoutString(layoutString, dag.nodes);\n  };\n\n  static async layoutNodes(nodes: Map<number, SatNode>) {\n    // generate dot string\n    const dotString = VizWrapper.nodesToDotString(nodes);\n\n    // use viz to compute layout for nodes given as dotstring\n    // note that viz returns the layout as a string\n    const layoutString = await runViz(dotString);\n\n    // parse the layout string into array of network-nodes\n    VizWrapper.parseLayoutString(layoutString, nodes);\n  }\n\n  // encodes layout-problem into dot-language\n  // the solution to the layout-problem contains a position for each node, which either\n  // - is a preprocessing node\n  // - occurs in the derivation of at least one activated clause\n  static dagToDotString(dag: Dag, onlyActiveDag: boolean): string {\n    const nodesInActiveDag = onlyActiveDag ? dag.computeNodesInActiveDag(Number.MAX_SAFE_INTEGER) : null;\n\n    const inputStrings = new Array<string>();\n    const preprocessingStrings = new Array<string>();\n    const otherStrings = new Array<string>();    \n    for (const node of dag.nodes.values()) {\n      assert(node.position === null, \"the dag has already been layouted!\");\n      if (node.isFromPreprocessing) {\n        if(dag.nodeIsInputNode(node.id)) {\n          inputStrings.push(`${node.id} [label=\"${node.toString()}\"]`);\n        } else {\n          preprocessingStrings.push(`${node.id} [label=\"${node.toString()}\"]`);\n        }\n      } else  {\n        if (!onlyActiveDag || (nodesInActiveDag as Set<number>).has(node.id)) {\n          otherStrings.push(`${node.id} [label=\"${node.toString()}\"]`);\n        }\n      }\n    }\n\n    const edgeStrings = new Array<string>();\n    for (const node of dag.nodes.values()) {\n      if (!onlyActiveDag || (nodesInActiveDag as Set<number>).has(node.id)) {\n        for (const parentId of node.parents) {\n          edgeStrings.push(`${parentId} -> ${node.id}`)\n        }\n      }\n    }\n\n    const inputString = \"   subgraph inputgraph {\\n      rank=source;\\n      \" + inputStrings.join(\";\\n      \") + \"\\n   }\";\n    const preprocessingString = \"   subgraph preprocessinggraph {\\n      rank=same;\\n      \" + preprocessingStrings.join(\";\\n      \") + \"\\n   }\";\n    const otherstring = \"   subgraph othergraph {\\n      \" + otherStrings.join(\";\\n      \") + \"\\n   }\";\n    const edgeString = edgeStrings.join(\";\\n   \");\n\n    const dotString =  \"digraph {\\n\\n\" + inputString + \"\\n\\n\" + preprocessingString + \"\\n\\n\" + otherstring + \"\\n\\n   \" + edgeString + \"\\n}\";\n    \n    return dotString;\n  };\n\n  static nodesToDotString(nodes: Map<number, SatNode>): string {\n    const nodeStrings = new Array<string>();\n    for (const node of nodes.values()) {\n      assert(node.position === null, \"the node has already been layouted!\");\n      nodeStrings.push(`${node.id} [label=\"${node.toString()}\"]`);\n    }\n\n    const edgeStrings = new Array<string>();\n    for (const node of nodes.values()) {\n      for (const parentId of node.parents) {\n        if (nodes.has(parentId)) {\n          edgeStrings.push(`${parentId} -> ${node.id}`)\n        }\n      }\n    }\n\n    const dotString =  \"digraph {\\n   \" + nodeStrings.join(\";\\n   \") + \"\\n\\n   \" + edgeStrings.join(\";\\n   \") + \"\\n}\";\n    return dotString;\n  };\n\n  static parseLayoutString(layoutString: string, nodes: Map<number, SatNode>) {\n    let firstEdgeLineIndex = layoutString.includes('\\nedge') ? layoutString.indexOf('\\nedge') : layoutString.length;\n    // split layoutString to array of strings describing positions of nodes\n    const parsedNodeLines = layoutString\n      .substr(0, firstEdgeLineIndex) // ignore remaining part of string describing edges\n      .split('\\nnode ') //split lines\n      .slice(1) // ignore first line describing graph\n      .map(line => line.substr(0, line.indexOf('\"'))) // ignore remaining part of line causing problems with line breaks\n      .map((line) => line.matchAll(PLAIN_PATTERN).next().value); // parse each remaining line\n    parsedNodeLines.forEach(line => {\n      assert(line !== undefined); // check that each remaining line was successfully parsed\n\t  });\n\t\n    // update SatNode for each nodeString\n    for (const parsedNodeLine of parsedNodeLines) {\n      const [, idString, xString, yString] = parsedNodeLine;\n      const id = parseInt(idString, 10);\n      const x = parseFloat(xString);\n      const y = parseFloat(yString);\n      const node = nodes.get(id) as SatNode;\n      node.position = [x,y];\n    }\n  }\n}","import * as React from 'react';\nimport ReactModal from 'react-modal';\n\nimport Graph from './Graph'\nimport { Dag } from '../model/dag';\nimport { assert } from '../model/util';\nimport { PassiveDagAside } from './PassiveDagAside';\nimport { Literal } from '../model/literal';\n\nimport { passiveDagForSelection } from '../model/transformations';\nimport { VizWrapper } from '../model/viz-wrapper';\n\nReactModal.setAppElement('#root');\n\ntype Props = {\n\tdag: Dag,\n\tnodeSelection: number[],\n  currentTime: number,\n\t\n\tchangedNodesEvent?: Set<number>,\n  infoToggle: boolean,\n  editToggle: boolean,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void\n\n\tonDismissPassiveDag: (selectedId: number | null, positioningHint: [number, number] | null) => void,\n  onToggleInfo: () => void,\n  onToggleEdit: () => void\n};\n\ntype State = {\n\tpassiveDag: Dag | null;\n  nodeSelectionPassiveDag: number[],\n}\n\nexport class PassiveDagModal extends React.Component<Props, State> {\n\t\n\tstate: State = {\n\t\tpassiveDag: null,\n\t\tnodeSelectionPassiveDag: []\n  }\n\n  async componentDidMount() {\n    const passiveDag = await this.generatePassiveDag();\n    this.setState({\n      passiveDag: passiveDag\n    });\n  }\n\n  async componentDidUpdate(previousProps) {\n\t\tif (this.props.dag !== previousProps.dag || this.props.nodeSelection !== previousProps.nodeSelection || this.props.currentTime !== previousProps.currentTime) {\n\t\t\tconst passiveDag = await this.generatePassiveDag();\n\t\t\tthis.setState({\n\t\t\t\tpassiveDag: passiveDag\n\t\t\t});\n\t\t}\n  }\n\n\trender() {\n\t\tif (this.state.passiveDag === null) {\n\t\t\treturn (\n\t\t\t\t<section>Layouting...</section>\n\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\t<ReactModal\n\t\t\t\tisOpen={true}\n\t\t\t\tcontentLabel={`Clauses currently in Passive generated by clause with id ${this.state.passiveDag!.activeNodeId!}`}\n\t\t\t\tonRequestClose={() => {\n\t\t\t\t\tthis.props.onDismissPassiveDag(null, null);\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<Graph\n\t\t\t\t\tdag={this.state.passiveDag!}\n\t\t\t\t\tnodeSelection={this.state.nodeSelectionPassiveDag}\n\t\t\t\t\tchangedNodesEvent={this.props.changedNodesEvent}\n\t\t\t\t\tcurrentTime={this.props.currentTime}\n\t\t\t\t\tanimateDagChanges={false}\n\t\t\t\t\tonNodeSelectionChange={this.nodeSelectionChange.bind(this)}\n\t\t\t\t\tonUpdateNodePositions={this.updateNodePositions.bind(this)}\n\t\t\t\t/>\n\t\t\t\t<PassiveDagAside\n\t\t\t\t\tdag={this.state.passiveDag!}\n\t\t\t\t\tcurrentTime={this.props.currentTime}\n\t\t\t\t\tnodeSelection={this.state.nodeSelectionPassiveDag}\n          infoToggle={this.props.infoToggle}\n          editToggle={this.props.editToggle}\n\t\t\t\t\tonUpdateNodeSelection={this.nodeSelectionChange.bind(this)}\n\t\t\t\t\tonLiteralOrientationChange={this.props.onLiteralOrientationChange}\n\t\t\t\t\tonLiteralRepresentationChange={this.props.onLiteralRepresentationChange}\n\t\t\t\t\tonSelectButtonPressed={this.selectButtonPressed.bind(this)}\n          onToggleInfo={this.props.onToggleInfo}\n          onToggleEdit={this.props.onToggleEdit}\n\t\t\t\t/>\n\t\t\t</ReactModal>\n\t\t)\n\t}\t\n\n\tnodeSelectionChange(selection: number[]) {\n\t\tthis.setState({nodeSelectionPassiveDag: selection});\n\t}\n\n\tupdateNodePositions(nodeIds: number[], delta: [number, number]) {\n\t\tassert(this.state.passiveDag !== null);\n    for (const nodeId of nodeIds) {\n      const node = this.state.passiveDag!.get(nodeId);\n      assert(node.position !== null);\n      node.position = [node.position![0] + delta[0], node.position![1] + delta[1]];\n    }\n\t}\n\n\tasync generatePassiveDag() {\n\t\t// generate passive dag\n\t\tconst passiveDag = passiveDagForSelection(this.props.dag, this.props.nodeSelection, this.props.currentTime);\n\n\t\t// layout node positions of passive dag\n\t\tawait VizWrapper.layoutDag(passiveDag, false);\n\n\t\t// shift dag so that selected node occurs at same screen position as in currentDag\n\t\tconst [posCurrentX, posCurrentY] = this.props.dag.get(this.props.nodeSelection[0]).getPosition();\n\t\tconst [posPassiveX, posPassiveY] = passiveDag.get(this.props.nodeSelection[0]).getPosition();\n\t\tconst deltaX = posCurrentX-posPassiveX;\n\t\tconst deltaY = posCurrentY-posPassiveY;\n\t\tfor (const node of passiveDag.nodes.values()) {\n\t\t\tassert(node.position != null);\n\t\t\tconst position = node.position as [number, number];\n\t\t\tnode.position = [position[0] + deltaX, position[1] + deltaY];\n\t\t}\n\n\t\treturn passiveDag;\n\t}\n\n\tselectButtonPressed() {\n\t\tconst passiveDag = this.state.passiveDag;\n\t\tassert(passiveDag !== null);\n\t\tassert(passiveDag!.isPassiveDag);\n\t\tassert(passiveDag!.activeNodeId !== null);\n\t\t\n\t\tassert(this.state.nodeSelectionPassiveDag.length === 1);\n\t\tconst selectedId = this.state.nodeSelectionPassiveDag[0];\n\t\tassert(selectedId !== null);\n\n\t\tconst styleMap = passiveDag!.styleMap!\n\t\tassert(styleMap !== null);\n    assert(styleMap.get(selectedId) === \"passive\");\n\t\t\n\t\t// compute positioning hint\n\t\tconst positioningHint = this.props.dag.get(this.state.passiveDag!.activeNodeId as number).position;\n\t\tassert(positioningHint !== null);\n\n\t\tthis.props.onDismissPassiveDag(selectedId, positioningHint!);\n\t}\n\n}\n","import * as React from 'react';\n\nimport {Dag} from '../model/dag';\nimport {Literal} from '../model/literal'\nimport Slider from './Slider';\nimport Graph from './Graph';\nimport {PassiveDagModal} from './PassiveDagModal';\n\n\ntype Props = {\n  dag: Dag,\n  showPassiveDag: boolean,\n  nodeSelection: number[],\n  changedNodesEvent?: Set<number>,\n  historyLength: number,\n  currentTime: number,\n  animateDagChanges: boolean,\n  infoToggle: boolean,\n  editToggle: boolean,\n  readOnly: boolean,\n  onNodeSelectionChange: (selection: number[]) => void,\n  onCurrentTimeChange: (newState: number) => void,\n  onDismissPassiveDag: (selectedId: number | null, positioningHint: [number, number] | null) => void,\n  onUpdateNodePositions: (nodeIds: Array<number>, delta: [number, number]) => void,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void,\n  onToggleInfo: () => void,\n  onToggleEdit: () => void\n};\n\nexport default class Main extends React.Component<Props, {}> {\n\n  render() {\n    let modal;\n    if (this.props.showPassiveDag) {\n      modal = \n        <PassiveDagModal\n          dag={this.props.dag}\n          nodeSelection={this.props.nodeSelection}\n          currentTime={this.props.currentTime}\n          changedNodesEvent={this.props.changedNodesEvent}\n          infoToggle={this.props.infoToggle}\n          editToggle={this.props.editToggle}\n          onLiteralOrientationChange={this.props.onLiteralOrientationChange}\n          onLiteralRepresentationChange={this.props.onLiteralRepresentationChange}\n          onDismissPassiveDag={this.props.onDismissPassiveDag}\n          onToggleInfo={this.props.onToggleInfo}\n          onToggleEdit={this.props.onToggleEdit}\n        />\n    }\n\n    const slider = this.props.readOnly ? (\n      <section className=\"slider-placeholder\"/>\n    ) : (\n      <Slider\n        historyLength={this.props.historyLength}\n        currentTime={this.props.currentTime}\n        onCurrentTimeChange={this.props.onCurrentTimeChange}\n      />\n    );\n\n    return (\n      <main>\n        <Graph\n          dag={this.props.dag}\n          nodeSelection={this.props.nodeSelection}\n          changedNodesEvent={this.props.changedNodesEvent}\n          currentTime={this.props.currentTime}\n          animateDagChanges={this.props.animateDagChanges}\n          onNodeSelectionChange={this.props.onNodeSelectionChange}\n          onUpdateNodePositions={this.props.onUpdateNodePositions}\n        />\n        {modal}\n        {slider}\n      </main>\n    );\n  }\n}\n","import * as React from 'react';\n\nimport './GraphMenu.css';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  undoEnabled: boolean,\n  filterUpEnabled: boolean,\n  filterDownEnabled: boolean,\n  passiveDagButtonEnabled: boolean,\n  onUndo: () => void,\n  onRenderParentsOnly: () => void,\n  onRenderChildrenOnly: () => void,\n  onShowPassiveDag: () => void\n};\n\nexport default class GraphMenu extends React.Component<Props, {}> {\n\n  render() {\n    return (\n      <div className=\"component-graph-menu\">\n        <section className=\"component-graph-menu-content\">\n          <button title=\"Undo last graph transformation\" disabled={!this.props.undoEnabled} onClick={this.props.onUndo}>\n            <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n              <use xlinkHref={`${icons}#graph-undo`}/>\n            </svg>\n          </button>\n\n          <button title=\"Render selection only (up)\" disabled={!this.props.filterUpEnabled}\n                  onClick={this.props.onRenderParentsOnly}>\n            <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n              <use xlinkHref={`${icons}#graph-up`}/>\n            </svg>\n          </button>\n\n          <button title=\"Render selection only (down)\" disabled={!this.props.filterDownEnabled}\n                  onClick={this.props.onRenderChildrenOnly}>\n            <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n              <use xlinkHref={`${icons}#graph-down`}/>\n            </svg>\n          </button>\n\n          <button title=\"Select clauses\"\n                  disabled={!this.props.passiveDagButtonEnabled}\n                  onClick={() => {\n                    this.props.onShowPassiveDag();\n                  }}>\n            <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n              <use xlinkHref={`${icons}#graph-s`}/>\n            </svg>\n          </button>\n        </section>\n      </div>\n    );\n  }\n}\n","import * as React from 'react';\n\nimport './NodeMenu.css';\n\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  nodeSelection: number[],\n  onSelectParents: () => void,\n  onSelectChildren: () => void,\n  onSelectCommonConsequences: () => void\n};\nexport default class NodeMenu extends React.Component<Props, {}> {\n\n  render() {\n    return (\n      <section className=\"component-node-menu\">\n\n        <button\n          title=\"Select parents of selected nodes\"\n          disabled={!this.props.nodeSelection.length}\n          onClick={this.props.onSelectParents}\n        >\n          <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n            <use xlinkHref={`${icons}#node-parents`}/>\n          </svg>\n        </button>\n\n        <button\n          title=\"Select children of selected nodes\"\n          disabled={!this.props.nodeSelection.length}\n          onClick={this.props.onSelectChildren}\n        >\n          <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n            <use xlinkHref={`${icons}#node-children`}/>\n          </svg>\n        </button>\n\n        <button\n          title=\"Find common consequences of selected nodes\"\n          disabled={this.props.nodeSelection.length < 2}\n          onClick={this.props.onSelectCommonConsequences}\n        >\n          <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n            <use xlinkHref={`${icons}#node-consequences`}/>\n          </svg>\n        </button>\n\n      </section>\n    );\n  }\n\n}\n","import * as React from 'react';\n\nimport { Dag } from '../model/dag';\nimport './Search.css';\nimport SatNode from '../model/sat-node';\nimport { assert } from '../model/util';\nimport { Clause } from '../model/unit';\n\n\ntype Props = {\n  dag: Dag | null,\n  currentTime: number,\n  onUpdateNodeSelection: (selection: number[]) => void\n};\ntype State = {\n  foundNodes: Array<SatNode>\n};\n\nexport default class Search extends React.Component<Props, State> {\n\n  state = {\n    foundNodes: []\n  };\n  private searchField1 = React.createRef<HTMLInputElement>();\n  private searchField2 = React.createRef<HTMLInputElement>();\n  private searchField3 = React.createRef<HTMLInputElement>();\n\n  componentDidUpdate(prevProps) {\n    if (this.props.dag !== prevProps.dag || this.props.currentTime !== prevProps.currentTime) {\n      this.searchField1.current!.value = \"\";\n      this.searchField2.current!.value = \"\";\n      this.searchField3.current!.value = \"\";\n\n      this.setState({foundNodes: []});\n    }\n  }\n\n  render() {\n    const {foundNodes} = this.state;\n\n    return (\n      <section className=\"component-search\">\n        <input\n          type=\"text\"\n          ref={this.searchField1}\n          placeholder=\"Search for nodes including literal\"\n          onKeyUp={this.search.bind(this)}\n          disabled={this.props.dag === null}\n        />\n        <input\n          type=\"text\"\n          ref={this.searchField2}\n          placeholder=\"Search for nodes excluding literals\"\n          onKeyUp={this.search.bind(this)}\n          disabled={this.props.dag === null}\n        />\n        <input\n          type=\"text\"\n          ref={this.searchField3}\n          placeholder=\"Search for nodes using inference rule\"\n          onKeyUp={this.search.bind(this)}\n          disabled={this.props.dag === null}\n        />\n        <ul id=\"searchResults\">\n          {\n            foundNodes.slice(0, 21).map(node => this.toListItem(node))\n          }\n          {\n            foundNodes.length > 20 && this.getDisabledListItem()\n          }\n        </ul>\n      </section>\n    );\n  }\n\n\n  // SEARCH ////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  search() {\n    assert(this.props.dag !== null);\n\n    assert(this.searchField1.current!);\n    assert(this.searchField2.current!);\n    assert(this.searchField3.current!);\n    const searchString1 = this.searchField1.current!.value;\n    const searchString2 = this.searchField2.current!.value;\n    const searchString3 = this.searchField3.current!.value;\n\n    // only perform search if at least one search string is non-empty\n    if (searchString1 === \"\" && searchString2 === \"\" && searchString3 === \"\") {\n      this.props.onUpdateNodeSelection([]);\n      this.setState({\n        foundNodes: []\n      });\n      return;\n    }\n\n    let candidates = Array.from(this.props.dag!.nodes.values());\n\n    // find all clauses which contain a literal which matches the first search string\n    if (searchString1 !== \"\") {\n      const foundNodes = new Array<SatNode>();\n  \n      for (const node of candidates) {\n        if (node.unit.type === \"Clause\") {\n          const clause = node.unit as Clause;\n        \n          let foundLiteral = false;\n          for (const literal of clause.premiseLiterals) {\n            if(literal.toString(true).includes(searchString1)) {\n              foundLiteral = true;\n              break;\n            }\n          }\n          if (!foundLiteral) {\n            for (const literal of clause.conclusionLiterals) {\n              if(literal.toString(false).includes(searchString1)) {\n                foundLiteral = true;\n                break;\n              }\n            }\n          }\n          if (!foundLiteral) {\n            for (const literal of clause.contextLiterals) {\n              if(literal.toString(false).includes(searchString1)) {\n                foundLiteral = true;\n                break;\n              }\n            }\n          }\n          if(foundLiteral) {\n            foundNodes.push(node);\n          }\n        }\n      }\n      candidates = foundNodes;\n    }\n\n    // find all clauses which don't contain a literal which matches the second search string\n    if (searchString2 !== \"\") {\n      const foundNodes = new Array<SatNode>();\n  \n      for (const node of candidates) {\n        if (node.unit.type === \"Clause\") {\n          const clause = node.unit as Clause;\n        \n          let foundLiteral = false;\n          for (const literal of clause.premiseLiterals) {\n            if(literal.toString(true).includes(searchString2)) {\n              foundLiteral = true;\n              break;\n            }\n          }\n          if (!foundLiteral) {\n            for (const literal of clause.conclusionLiterals) {\n              if(literal.toString(false).includes(searchString2)) {\n                foundLiteral = true;\n                break;\n              }\n            }\n          }\n          if (!foundLiteral) {\n            for (const literal of clause.contextLiterals) {\n              if(literal.toString(false).includes(searchString2)) {\n                foundLiteral = true;\n                break;\n              }\n            }\n          }\n\n          if(!foundLiteral) {\n            foundNodes.push(node);\n          }\n        }\n      }\n      candidates = foundNodes;\n    }\n\n    // find all clauses which have been derived using an inference rule which matches the third search string\n    if (searchString3 !== \"\") {\n      const foundNodes = new Array<SatNode>();\n  \n      for (const node of candidates) {\n        // note: using an exact check here instead of includes check\n        // e.g. so that \"resolution\" does not match \"subsumption resolution\"\n        if (node.inferenceRule === searchString3) {\n          foundNodes.push(node);\n        }\n      }\n      candidates = foundNodes;\n    }\n\n    const nodesInActiveDag = this.props.dag!.computeNodesInActiveDag(this.props.currentTime);\n    const foundNodes = new Array<SatNode>();\n    for (const node of candidates) {\n      if (nodesInActiveDag.has(node.id)) {\n        foundNodes.push(node);\n      }\n    }\n    candidates = foundNodes;\n\n    // order found clauses by length\n    candidates.sort((node1: SatNode, node2: SatNode) => {\n      const clause1 = node1.unit as Clause;\n      const clause2 = node2.unit as Clause;\n      return clause1.toString().length - clause2.toString().length\n    });\n\n    // select all found clauses\n    this.props.onUpdateNodeSelection(candidates.map(node => node.id));\n  \n    // present search results\n    this.setState({\n      foundNodes: candidates\n    });\n  }\n\n  toListItem = (node: SatNode) => {\n    return <li key={node.id} onClick={() => this.props.onUpdateNodeSelection([node.id])}>{node.toString()}</li>;\n  };\n\n  getDisabledListItem = () => {\n    return <li className=\"disabled-element\">...</li>;\n  };\n\n}\n","import * as React from 'react';\n\nimport { Dag } from '../model/dag';\nimport NodeMenu from './NodeMenu';\nimport Search from './Search';\nimport './NodeCard.css';\n\ntype Props = {\n  dag: Dag | null,\n  currentTime: number,\n  nodeSelection: number[],\n  onUpdateNodeSelection: (selection: number[]) => void,\n  onSelectParents: () => void,\n  onSelectChildren: () => void,\n  onSelectCommonConsequences: () => void\n};\nexport default class NodeCard extends React.Component<Props, {}> {\n\n  render() {\n    return (\n      <section className=\"component-node-card\">\n        <article>\n          <h2>Select Nodes</h2>\n          <NodeMenu\n            nodeSelection={this.props.nodeSelection}\n            onSelectParents={this.props.onSelectParents}\n            onSelectChildren={this.props.onSelectChildren}\n            onSelectCommonConsequences={this.props.onSelectCommonConsequences}\n          />\n          <Search\n            dag={this.props.dag}\n            currentTime={this.props.currentTime}\n            onUpdateNodeSelection={this.props.onUpdateNodeSelection}\n          />\n        </article>\n      </section>\n    );\n  }\n\n}\n","import * as React from 'react';\n\nimport GraphMenu from './GraphMenu';\nimport NodeCard from './NodeCard';\nimport {Dag} from '../model/dag';\nimport {Literal} from '../model/literal';\nimport {assert} from '../model/util';\nimport {NodeDetailsWrapper} from './NodeDetailsWrapper';\n\n\ntype Props = {\n  dag: Dag | null,\n  currentTime: number,\n  nodeSelection: number[],\n  multipleVersions: boolean,\n  infoToggle: boolean,\n  editToggle: boolean,\n  readOnly: boolean,\n  onUpdateNodeSelection: (selection: number[]) => void,\n  onUndo: () => void,\n  onRenderParentsOnly: () => void,\n  onRenderChildrenOnly: () => void,\n  onShowPassiveDag: () => void,\n  onSelectParents: () => void,\n  onSelectChildren: () => void,\n  onSelectCommonConsequences: () => void,\n  onLiteralOrientationChange: (nodeId: number, oldPosition: ['premise' | 'conclusion' | 'context', number], newPosition: ['premise' | 'conclusion' | 'context', number]) => void,\n  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void,\n  onToggleInfo: () => void,\n  onToggleEdit: () => void\n};\nexport default class Aside extends React.Component<Props, {}> {\n\n  render() {\n    if (this.props.dag === null) {\n      assert(this.props.nodeSelection.length === 0);\n      assert(!this.props.multipleVersions);\n    }\n\n    const graphMenuEnabled = !this.props.readOnly && this.props.dag !== null;\n    const undoEnabled = graphMenuEnabled && this.props.multipleVersions;\n    const filtersEnabled = graphMenuEnabled && this.props.nodeSelection.length > 0 && !this.props.dag!.isPassiveDag;\n    const passiveDagButtonEnabled = graphMenuEnabled && this.props.nodeSelection.length > 0;\n\n    return (\n      <div className=\"scroll\">\n        <aside>\n          <GraphMenu\n            undoEnabled={undoEnabled}\n            filterUpEnabled={filtersEnabled}\n            filterDownEnabled={filtersEnabled}\n            passiveDagButtonEnabled={passiveDagButtonEnabled}\n            onUndo={this.props.onUndo}\n            onRenderParentsOnly={this.props.onRenderParentsOnly}\n            onRenderChildrenOnly={this.props.onRenderChildrenOnly}\n            onShowPassiveDag={this.props.onShowPassiveDag}\n          />\n          <NodeCard\n            dag={this.props.dag}\n            currentTime={this.props.currentTime}\n            nodeSelection={this.props.nodeSelection}\n            onUpdateNodeSelection={this.props.onUpdateNodeSelection}\n            onSelectParents={this.props.onSelectParents}\n            onSelectChildren={this.props.onSelectChildren}\n            onSelectCommonConsequences={this.props.onSelectCommonConsequences}\n          />\n          <NodeDetailsWrapper\n            dag={this.props.dag}\n            nodeSelection={this.props.nodeSelection}\n            currentTime={this.props.currentTime}\n            infoToggle={this.props.infoToggle}\n            editToggle={this.props.editToggle}\n            onLiteralOrientationChange={this.props.onLiteralOrientationChange}\n            onLiteralRepresentationChange={this.props.onLiteralRepresentationChange}\n            onToggleInfo={this.props.onToggleInfo}\n            onToggleEdit={this.props.onToggleEdit}\n          />\n        </aside>\n      </div>\n    );\n  }\n\n}\n","import { Dag } from \"./dag\";\nimport { Clause } from \"./unit\";\nimport { Literal } from \"./literal\";\nimport { assert } from \"./util\";\nimport { literalsMatch } from \"./substitution\";\nimport { DFPostOrderTraversal } from \"./traversal\";\n\n// inferences, where\n// 1) clause and parent clause have same number of literals\n// 2) rewritten literals occur in the same position as the corresponding literal in the parent clause\nfunction computeParentLiteralsCase1(literals: Array<Literal>, parentLiterals: Array<Literal>) {\n\tassert(literals.length === parentLiterals.length);\n\n\tfor (let i = 0; i < literals.length; i++) {\n\t\tconst literal = literals[i];\n\t\tconst parentLiteral = parentLiterals[i];\n\t\t\n\t\tliteral.setLiteralInParent(parentLiteral);\n\t}\n}\n\n// inferences which remove exactly one literal, where the order of the remaining literals is not changed\n// need to find the position where the literals were removed\n// note: this may compute a wrong matching if a literal in the side-part of the clause matches a deleted literal\n//       in this case the wrongly matched literals in the parent are pairwise unifiable, so a sane user would assign to all of them the same orientation.\n//       in particular the wrong matching should not affect the orientation-heuristic in practice\nfunction computeParentLiteralsCase2(literals: Array<Literal>, parentLiterals: Array<Literal>, allowSubstitutions: boolean, allowMultipleRemovals: boolean) {\n\tassert(allowMultipleRemovals ? (literals.length < parentLiterals.length) : (literals.length + 1 === parentLiterals.length));\n\n\tlet foundRemovedLit = false;\n\tlet i = 0;\n\tlet j = 0;\n\twhile (i < literals.length) {\n\t\tconst literal = literals[i];\n\t\tconst parentLiteral = parentLiterals[j];\n\n\t\tconst success = literalsMatch(literal, parentLiteral, allowSubstitutions);\n\n\t\tif (success) {\n\t\t\tliteral.setLiteralInParent(parentLiteral);\n\t\t\ti = i + 1;\n\t\t\tj = j + 1;\n\t\t} else {\n\t\t\tassert(!foundRemovedLit || allowMultipleRemovals, `case 2 error:\\n${literals.toString()}\\n${parentLiterals.toString()}`);\n\t\t\tfoundRemovedLit = true;\n\t\t\tj = j + 1;\n\t\t}\n\t}\n}\n\n// inferences, which rewrite exactly one literal, and shift that literal to the first position in literals\n// need to find the position where the literal was rewritten\n// note: this may compute a wrong matching if a literal in the side-part of the clause matches the rewritten literal in the parent\n//       in this case the wrongly matched literals in the parent are pairwise unifiable, so a sane user would assign to all of them the same orientation.\n//       in particular the wrong matching should not affect the orientation-heuristic in practice\n// we also need to support simultanous superposition, which not only rewrites one literal and shifts that literal to the first position, but also allows other\n// literals to be rewritten. In particular, we are then not able anymore to always succeed with matching literals. In that case, we try to do an educated guess\n// of the ordering (in a way such that we compute the right literal matches at least in the case of non-simultanous superposition).\nfunction computeParentLiteralsCase3(literals: Array<Literal>, parentLiterals: Array<Literal>, allowSubstitutions: boolean, allowSimultanousSuperposition: boolean) {\n\tassert(literals.length === parentLiterals.length, `case 3 error:\\n${literals.toString()}\\n${parentLiterals.toString()}`);\n\n\tlet foundRewrittenLiteral = false;\n\tlet i = 1;\n\t// first shifted matchings can occur\n\twhile(i < literals.length) {\n\t\tconst literal = literals[i];\n\t\tconst parentLiteral = parentLiterals[i - 1];\n\n\t\tif (literalsMatch(literal, parentLiteral, allowSubstitutions)) {\n\t\t\tliteral.setLiteralInParent(parentLiteral);\n\t\t\ti = i + 1;\n\t\t} else {\n\t\t\t// shifted matching failed, so parentLiterals[i - 1] must be rewrittenLiteral\n\t\t\tliterals[0].setLiteralInParent(parentLiterals[i - 1]);\n\t\t\tfoundRewrittenLiteral = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// corner case where rewritten literal is last element of parent clause and therefore has no failing shifted matching\n\tif (!foundRewrittenLiteral) {\n\t\tassert(i === literals.length);\n\t\tliterals[0].setLiteralInParent(parentLiterals[parentLiterals.length - 1]);\n\t}\n\t// now nonshifted matchings can occur\n\twhile(i < literals.length) {\n\t\tconst literal = literals[i];\n\t\tconst parentLiteral = parentLiterals[i];\n\t\tif (!allowSimultanousSuperposition) {\n\t\t\tassert(literalsMatch(literal, parentLiteral, allowSubstitutions), `case 3 error: literal ${i} doesn't match parent literal.\\n${literals.toString()}\\n${parentLiterals.toString()}\\n`);\n\t\t}\n\t\tliteral.setLiteralInParent(parentLiteral);\n\t\ti = i + 1;\n\t}\n}\n\n\nexport function computeParentLiterals(dag: Dag) {\n\tfor (const node of dag.nodes.values()) {\n\t\tif (!node.isBoundary && node.unit.type === \"Clause\") {\n\t\t\tconst clause = node.unit as Clause;\n\n\t\t\tif (node.inferenceRule === \"evaluation\" ||\n\t\t\t\tnode.inferenceRule === \"forward subsumption demodulation\" ||\n\t\t\t\t(node.inferenceRule === \"term algebras injectivity\" && node.parents.length === 1) ||\n\t\t\t\tnode.inferenceRule === \"subsumption resolution\" ||\n\t\t\t\tnode.inferenceRule === \"equality resolution\" ||\n\t\t\t\tnode.inferenceRule === \"trivial inequality removal\" ||\n\t\t\t\tnode.inferenceRule === \"factoring\" ||\n\t\t\t\tnode.inferenceRule === \"duplicate literal removal\" ||\n\t\t\t\t(node.inferenceRule === \"term algebras distinctness\" && node.parents.length === 1) ||\n\t\t\t\tnode.inferenceRule === \"forward demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"backward demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"equality factoring\") {\n\t\t\t\tassert(node.parents.length > 0);\n\n\t\t\t\t// we assume that the first parent is the main premise\n\t\t\t\tconst parent = dag.get(node.parents[0]);\n\n\t\t\t\t// only compute literal matchings for clauses\n\t\t\t\tif (parent.unit.type === \"Clause\") {\n\t\t\t\t\tconst parentClause = parent.unit as Clause;\n\n\t\t\t\t\t// compute literal ordering at the timepoint where clause was generated\n\t\t\t\t\t// note that the active-event can change the order of literals (since at this point the selected literals are computed and shifted to the front)\n\t\t\t\t\tassert(node.newTime !== null);\n\t\t\t\t\tassert(parent.newTime !== null);\n\t\t\t\t\tconst parentWasAlreadyActivated = parent.activeTime !== null && parent.activeTime <= node.newTime!;\n\t\t\t\t\tconst parentLiterals = parentWasAlreadyActivated ? parentClause.literalsActiveEvent! : parentClause.literalsNewEvent!;\n\t\t\t\t\tconst literals = clause.literalsNewEvent!;\n\t\t\t\t\tassert(parentLiterals !== null);\n\t\t\t\t\tassert(literals !== null);\n\n\t\t\t\t\t// compute the literal-matchings\n\t\t\t\t\t// in full generality, this computation would be computationally expensive and a lot of implementation effort\n\t\t\t\t\t// instead, we hardcode computations of matchings for the most important inference rules implemented in Vampire, and don't compute matchings for other inferences\n\t\t\t\t\tif ((node.inferenceRule === \"evaluation\" && literals.length === parentLiterals.length) || \n\t\t\t\t\t\tnode.inferenceRule === \"forward subsumption demodulation\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"term algebras injectivity\") {\n\n\t\t\t\t\t\tcomputeParentLiteralsCase1(literals, parentLiterals);\n\n\t\t\t\t\t} else if (node.inferenceRule === \"subsumption resolution\" || \n\t\t\t\t\t\tnode.inferenceRule === \"equality resolution\" || \n\t\t\t\t\t\tnode.inferenceRule === \"trivial inequality removal\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"factoring\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"duplicate literal removal\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"term algebras distinctness\" ||\n\t\t\t\t\t\t(node.inferenceRule === \"evaluation\" && literals.length + 1 === parentLiterals.length)) {\n\n\t\t\t\t\t\tconst allowSubstitutions = node.inferenceRule === \"equality resolution\" || node.inferenceRule === \"factoring\";\n\t\t\t\t\t\tconst allowMultipleRemovals = node.inferenceRule === \"trivial inequality removal\" || node.inferenceRule === \"duplicate literal removal\";\n\t\t\t\t\t\tcomputeParentLiteralsCase2(literals, parentLiterals, allowSubstitutions, allowMultipleRemovals);\n\n\t\t\t\t\t} else if (node.inferenceRule === \"forward demodulation\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"backward demodulation\" ||\n\t\t\t\t\t\tnode.inferenceRule === \"equality factoring\") {\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst allowSubstitutions = node.inferenceRule === \"equality factoring\";\n\t\t\t\t\t\tcomputeParentLiteralsCase3(literals, parentLiterals, allowSubstitutions, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.inferenceRule === \"resolution\" ||\n\t\t\t\tnode.inferenceRule === \"superposition\") {\n\t\t\t\tassert(node.parents.length === 2);\n\t\t\t\tconst leftNode = dag.get(node.parents[0]);\n\t\t\t\tconst rightNode = dag.get(node.parents[1]);\n\n\t\t\t\t// only compute literal matchings for clauses\n\t\t\t\tif (leftNode.unit.type === \"Clause\" && rightNode.unit.type === \"Clause\") {\n\t\t\t\t\tconst leftClause = leftNode.unit as Clause;\n\t\t\t\t\tconst rightClause = rightNode.unit as Clause;\n\n\t\t\t\t\t// compute literal ordering at the timepoint where clause was generated\n\t\t\t\t\t// note again that the active-event can change the order of literals (since at this point the selected literals are computed and shifted to the front)\n\t\t\t\t\tassert(node.newTime !== null);\n\t\t\t\t\tassert(leftNode.newTime !== null);\n\t\t\t\t\tassert(rightNode.newTime !== null);\n\t\t\t\t\tconst leftWasAlreadyActivated = leftNode.activeTime !== null && leftNode.activeTime <= node.newTime!;\n\t\t\t\t\tconst rightWasAlreadyActivated = rightNode.activeTime !== null && rightNode.activeTime <= node.newTime!;\n\t\t\t\t\tconst leftLiterals = leftWasAlreadyActivated ? leftClause.literalsActiveEvent! : leftClause.literalsNewEvent!;\n\t\t\t\t\tconst rightLiterals = rightWasAlreadyActivated ? rightClause.literalsActiveEvent! : rightClause.literalsNewEvent!;\n\t\t\t\t\tconst literals = clause.literalsNewEvent!;\n\t\t\t\t\tassert(leftLiterals !== null);\n\t\t\t\t\tassert(rightLiterals !== null);\n\t\t\t\t\tassert(literals !== null);\n\t\t\t\t\tassert(leftLiterals.length > 0);\n\t\t\t\t\tassert(rightLiterals.length > 0);\n\n\t\t\t\t\tif (node.inferenceRule === \"resolution\") {\n\t\t\t\t\t\tassert(literals.length + 2 === leftLiterals.length + rightLiterals.length);\n\n\t\t\t\t\t\t// compute matchings separately for literals coming from leftLiterals resp. rightLiterals\n\t\t\t\t\t\t// split denotes the first position in literals with a literal coming from rightLiterals\n\t\t\t\t\t\tconst split = leftLiterals.length - 1;\n\t\t\t\t\t\tcomputeParentLiteralsCase2(literals.slice(0, split), leftLiterals, true, false);\n\t\t\t\t\t\tcomputeParentLiteralsCase2(literals.slice(split, literals.length), rightLiterals, true, false);\n\n\t\t\t\t\t} else if (node.inferenceRule === \"superposition\") {\n\t\t\t\t\t\tassert(literals.length + 1 === leftLiterals.length + rightLiterals.length);\n\n\t\t\t\t\t\t// compute matchings separately for literals coming from leftLiterals resp. rightLiterals\n\t\t\t\t\t\t// split denotes the first position in literals with a literal coming from rightLiterals\n\t\t\t\t\t\tconst split = leftLiterals.length;\n\t\t\t\t\t\tcomputeParentLiteralsCase3(literals.slice(0, split), leftLiterals, true, true);\n\t\t\t\t\t\tcomputeParentLiteralsCase2(literals.slice(split, literals.length), rightLiterals, true, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// update in the given dag:\n// - literal orientations\n// - literal representations\n// - ordering of literals in premises and conclusions\n// if changedClauseId is null, update all nodes in the dag\n// if changedClauseId is the id of a clause, update the node and all children of the node\n// Precondition: computeParentLiterals was already called on the current dag\nexport function computeClauseRepresentation(dag: Dag, changedClauseId: number | null): Set<number> {\n\tassert(changedClauseId === null || dag.nodes.has(changedClauseId));\n\n\tconst changedClauses = new Set<number>();\n\tif (changedClauseId !== null) {\n\t\tchangedClauses.add(changedClauseId);\n\t}\n\n\tconst iterator = new DFPostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tlet node = iterator.getNext();\n\n\t\tif (!node.isBoundary && node.unit.type === \"Clause\") {\n\t\t\tconst clause = node.unit as Clause;\n\n\t\t\t// compute whether clause should be updated. This is the case if\n\t\t\t// 1) all nodes should be updated (since changedClauseId === null)\n\t\t\t// 2) the node is changedClauseId\n\t\t\t// 3) a parent of node was changed\n\t\t\tlet update = changedClauseId === null || node.id === changedClauseId;\n\t\t\tif (!update) {\n\t\t\t\tfor (const parentId of node.parents) {\n\t\t\t\t\tif (changedClauses.has(parentId)) {\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Part 1: partition literals into premise and conclusion and compute literal-representation\n\t\t\t// Hack: Vampire by default uses \"equality resolution with deletion\" as inference rule during preprocessing.\n\t\t\t//       Unfortunately the produced inference is named \"equality resolution\" and therefore clashes with\n\t\t\t//       inferences produced by the generating inference rule with the same name.\n\t\t\t//       We therefore check that inferences with name \"equality resolution\" are not \"equality resolution with deletion\"-inferences.\n\t\t\tconst isEqualityResolutionWithDeletion = node.inferenceRule === \"equality resolution\" && dag.get(node.parents[0]).isFromPreprocessing === true;\n\t\t\tconst propagateSingleParent = node.inferenceRule === \"subsumption resolution\" ||\n\t\t\t\t(node.inferenceRule === \"equality resolution\" && !isEqualityResolutionWithDeletion) ||\n\t\t\t\tnode.inferenceRule === \"equality factoring\" ||\n\t\t\t\tnode.inferenceRule === \"forward demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"backward demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"forward subsumption demodulation\" ||\n\t\t\t\tnode.inferenceRule === \"factoring\" ||\n\t\t\t\tnode.inferenceRule === \"duplicate literal removal\" ||\n\t\t\t\tnode.inferenceRule === \"evaluation\" ||\n\t\t\t\tnode.inferenceRule === \"trivial inequality removal\" ||\n\t\t\t\t(node.inferenceRule === \"term algebras injectivity\" && node.parents.length === 1) ||\n\t\t\t\t(node.inferenceRule === \"term algebras distinctness\" && node.parents.length === 1);\n\t\t\tconst propagateTwoParents = node.inferenceRule === \"resolution\" ||\n\t\t\t\tnode.inferenceRule === \"superposition\";\n\n\t\t\tconst premiseLiterals = new Array<Literal>();\n\t\t\tconst conclusionLiterals = new Array<Literal>();\n\t\t\tconst contextLiterals = new Array<Literal>();\n\t\t\tfor (const literal of clause.premiseLiterals.concat(clause.conclusionLiterals, clause.contextLiterals)) {\n\n\t\t\t\tlet orientation: \"premise\" | \"conclusion\" | \"context\" | null = null;\n\n\t\t\t\tconst parentLiteral = literal.literalInParent;\n\t\t\t\tif (literal.orientationReason !== \"user\" && (propagateSingleParent || propagateTwoParents)) {\n\t\t\t\t\tassert(parentLiteral !== null);\n\t\t\t\t\t// propagate orientation and representation from parent literal\n\t\t\t\t\tliteral.representation = parentLiteral!.representation;\n\t\t\t\t\tif (propagateSingleParent) {\n\t\t\t\t\t\tassert(node.parents.length > 0);\n\n\t\t\t\t\t\t// we assume that the first parent is the main premise\n\t\t\t\t\t\tconst parent = dag.get(node.parents[0]);\n\n\t\t\t\t\t\tif (parent.unit.type === \"Clause\") {\n\t\t\t\t\t\t\tconst parentClause = parent.unit as Clause;\n\t\t\t\t\t\t\t// figure out whether parentLiteral occurs in premise or conclusion and set orientation accordingly\n\t\t\t\t\t\t\tif (parentClause.premiseLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t\t\t} else if (parentClause.conclusionLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tassert(parentClause.contextLiterals.find(l => l === parentLiteral));\n\t\t\t\t\t\t\t\torientation = \"context\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (propagateTwoParents) {\n\t\t\t\t\t\tassert(node.parents.length === 2);\n\t\t\t\t\t\tconst leftNode = dag.get(node.parents[0]);\n\t\t\t\t\t\tconst rightNode = dag.get(node.parents[1]);\n\t\t\t\t\t\tif (leftNode.unit.type === \"Clause\" && rightNode.unit.type === \"Clause\") {\n\t\t\t\t\t\t\tconst leftClause = leftNode.unit as Clause;\n\t\t\t\t\t\t\tconst rightClause = rightNode.unit as Clause;\n\t\t\t\t\t\t\t// figure out whether parentLiteral occurs in premise or conclusion of left or right premise and set orientation accordingly\n\t\t\t\t\t\t\tif (leftClause.premiseLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t\t\t} else if (leftClause.conclusionLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t\t\t} else if (leftClause.contextLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"context\";\n\t\t\t\t\t\t\t} else if (rightClause.premiseLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t\t\t} else if (rightClause.conclusionLiterals.find(l => l === parentLiteral)) {\n\t\t\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tassert(rightClause.contextLiterals.find(l => l === parentLiteral));\n\t\t\t\t\t\t\t\torientation = \"context\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tliteral.orientationReason = \"inherited\"\n\t\t\t\t}\n\n\t\t\t\t// otherwise decide whether current orientation should be kept or whether it should be computed using a heuristic\n\t\t\t\telse if (literal.orientationReason !== \"none\" ) {\n\t\t\t\t\tif (clause.premiseLiterals.find(l => l === literal)) {\n\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t} else if (clause.conclusionLiterals.find(l => l === literal)) {\n\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert(clause.contextLiterals.find(l => l === literal))\n\t\t\t\t\t\torientation = \"context\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// use heuristic to compute orientation\n\t\t\t\t\tif (literal.negated && literal.name !== \"=\") {\n\t\t\t\t\t\torientation = \"premise\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\torientation = \"conclusion\";\n\t\t\t\t\t}\n\t\t\t\t\tliteral.orientationReason = \"heuristic\";\n\t\t\t\t}\n\n\t\t\t\tif (orientation === \"premise\") {\n\t\t\t\t\tpremiseLiterals.push(literal);\n\t\t\t\t} else if (orientation === \"conclusion\") {\n\t\t\t\t\tconclusionLiterals.push(literal);\n\t\t\t\t} else {\n\t\t\t\t\tassert(orientation === \"context\");\n\t\t\t\t\tcontextLiterals.push(literal);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Part 2: order literals according to the order of literals in the parents\n\t\t\t// only sort if no manually oriented literal in clause\n\t\t\tlet existsUserOrientedLiteral = false;\n\t\t\tfor (const literal of clause.premiseLiterals.concat(clause.conclusionLiterals, clause.contextLiterals)) {\n\t\t\t\tif (literal.orientationReason === \"user\") {\n\t\t\t\t\texistsUserOrientedLiteral = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!existsUserOrientedLiteral && propagateSingleParent) {\n\t\t\t\t// we assume that the first parent is the main premise\n\t\t\t\tconst parent = dag.get(node.parents[0]);\n\t\t\t\t\n\t\t\t\tif (parent.unit.type === \"Clause\") {\n\t\t\t\t\tconst parentClause = parent.unit as Clause;\n\n\t\t\t\t\t// generate map parentLiteral -> indexInPremise\n\t\t\t\t\tconst premiseIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < parentClause.premiseLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = parentClause.premiseLiterals[i];\n\t\t\t\t\t\tpremiseIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\t// generate map parentLiteral -> indexInConclusion\n\t\t\t\t\tconst conclusionIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < parentClause.conclusionLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = parentClause.conclusionLiterals[i];\n\t\t\t\t\t\tconclusionIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\t// generate map parentLiteral -> indexInContext\n\t\t\t\t\tconst contextIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < parentClause.contextLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = parentClause.contextLiterals[i];\n\t\t\t\t\t\tcontextIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\t// sort premise, conclusion and context\n\t\t\t\t\tpremiseLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = premiseIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = premiseIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t\tconclusionLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = conclusionIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = conclusionIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t\tcontextLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = contextIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = contextIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (!existsUserOrientedLiteral && propagateTwoParents) {\n\t\t\t\tassert(node.parents.length === 2);\n\t\t\t\tconst leftNode = dag.get(node.parents[0]);\n\t\t\t\tconst rightNode = dag.get(node.parents[1]);\n\t\t\t\tif (leftNode.unit.type === \"Clause\" && rightNode.unit.type === \"Clause\") {\n\t\t\t\t\tconst leftClause = leftNode.unit as Clause;\n\t\t\t\t\tconst rightClause = rightNode.unit as Clause;\n\n\t\t\t\t\t// generate map leftLiteral/rightLiteral -> indexInPremise\n\t\t\t\t\t// ensure that rightLiterals have a higher index than leftLiterals\n\t\t\t\t\tconst premiseIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < leftClause.premiseLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = leftClause.premiseLiterals[i];\n\t\t\t\t\t\tpremiseIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < rightClause.premiseLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = rightClause.premiseLiterals[i];\n\t\t\t\t\t\tpremiseIndexMap.set(parentLiteral, i + leftClause.premiseLiterals.length);\n\t\t\t\t\t}\n\t\t\t\t\t// generate map leftLiteral/rightLiteral -> indexInConclusion\n\t\t\t\t\t// ensure that rightLiterals have a higher index than leftLiterals\n\t\t\t\t\tconst conclusionIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < leftClause.conclusionLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = leftClause.conclusionLiterals[i];\n\t\t\t\t\t\tconclusionIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < rightClause.conclusionLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = rightClause.conclusionLiterals[i];\n\t\t\t\t\t\tconclusionIndexMap.set(parentLiteral, i + leftClause.conclusionLiterals.length);\n\t\t\t\t\t}\n\t\t\t\t\t// generate map leftLiteral/rightLiteral -> indexInContext\n\t\t\t\t\t// ensure that rightLiterals have a higher index than leftLiterals\n\t\t\t\t\tconst contextIndexMap = new Map<Literal, number>();\n\t\t\t\t\tfor (let i = 0; i < leftClause.contextLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = leftClause.contextLiterals[i];\n\t\t\t\t\t\tcontextIndexMap.set(parentLiteral, i);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < rightClause.contextLiterals.length; i++) {\n\t\t\t\t\t\tconst parentLiteral = rightClause.contextLiterals[i];\n\t\t\t\t\t\tcontextIndexMap.set(parentLiteral, i + leftClause.contextLiterals.length);\n\t\t\t\t\t}\n\n\t\t\t\t\t// sort premise, conclusion and context\n\t\t\t\t\tpremiseLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = premiseIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = premiseIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t\tconclusionLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = conclusionIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = conclusionIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t\tcontextLiterals.sort((lit1: Literal, lit2: Literal) => {\n\t\t\t\t\t\tassert(lit1.literalInParent !== null);\n\t\t\t\t\t\tassert(lit2.literalInParent !== null);\n\t\t\t\t\t\tconst index1 = contextIndexMap.get(lit1.literalInParent!);\n\t\t\t\t\t\tconst index2 = contextIndexMap.get(lit2.literalInParent!);\n\t\t\t\t\t\tassert(index1 !== undefined);\n\t\t\t\t\t\tassert(index2 !== undefined);\n\t\t\t\t\t\treturn index1! - index2!;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Part 3: update literals\n\t\t\tclause.premiseLiterals = premiseLiterals;\n\t\t\tclause.conclusionLiterals = conclusionLiterals;\n\t\t\tclause.contextLiterals = contextLiterals;\n\n\t\t\t// Part 4: mark clause to be changed\n\t\t\tchangedClauses.add(node.id);\n\t\t}\n\t}\n\n\treturn changedClauses;\n}\n\n\n\n\n\n","import {assert} from './util'\nimport {Unit, Formula, Clause} from './unit'\nimport {Literal, Term} from './literal'\nimport { Dag } from './dag'\nimport SatNode from './sat-node';\nimport { computeParentLiterals } from './clause-orientation';\n\nexport class Serializer {\n\treadonly version = 1 // the version number of the Serializer. The version number will be added to the generated json.\n\n\tstatic serializeAppState(problem: string, vampireUserOptions: string, dag: Dag): string {\n\t\tassert(!dag.isPassiveDag);\n\n\t\tconst obj = {\n      \"version\": 1,\n      \"problem\": problem,\n      \"vampireUserOptions\": vampireUserOptions,\n      \"dag\": dag\n\t\t};\n\n\t\tconst replacer = (key, value) => {\n\t\t\t// ignore several properties\n\t\t\tif (key === \"leaves\" ||\n\t\t\t\tkey === \"mergeMap\" ||\n\t\t\t\tkey === \"isPassiveDag\" ||\n\t\t\t\tkey === \"styleMap\" ||\n\t\t\t\tkey === \"activeNodeId\" ||\n\t\t\t\tkey === \"literalInParent\" ||\n\t\t\t\tkey === \"isVariable\") {\n\t\t\t\t\n\t\t\t\treturn undefined; \n\t\t\t}\n\t\t\t// encode premise-, conclusion-, and context-literals of Clauses\n\t\t\tif (key === \"unit\") {\n\t\t\t\tconst unit = (value as Unit);\n\t\t\t\tif (unit.type === \"Clause\") {\n\t\t\t\t\tconst clause = (value as Clause);\n\n\t\t\t\t\tconst convertToIndices = (literals) => {\n\t\t\t\t\t\tconst encodedLiterals = new Array<number>();\n\t\t\t\t\t\tfor (const lit1 of literals) {\n\t\t\t\t\t\t\tfor (let i = 0; i < clause.literalsNewEvent.length; i++) {\n\t\t\t\t\t\t\t\tconst lit2 = clause.literalsNewEvent[i];\n\t\t\t\t\t\t\t\tif (lit1 === lit2) {\n\t\t\t\t\t\t\t\t\tencodedLiterals.push(i);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn encodedLiterals;\n\t\t\t\t\t}\n\t\t\t\t\tconst encodedPremiseLiterals = convertToIndices(clause.premiseLiterals);\n\t\t\t\t\tconst encodedConclusionLiterals = convertToIndices(clause.conclusionLiterals);\n\t\t\t\t\tconst encodedContextLiterals = convertToIndices(clause.contextLiterals);\n\t\t\t\t\tconst encodedLiteralsActiveEvent = clause.literalsActiveEvent === null ? null : convertToIndices(clause.literalsActiveEvent);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t\"type\": \"Clause\", \n\t\t\t\t\t\t\"literalsNewEvent\": clause.literalsNewEvent, \n\t\t\t\t\t\t\"premiseLiterals\": encodedPremiseLiterals, \n\t\t\t\t\t\t\"conclusionLiterals\": encodedConclusionLiterals, \n\t\t\t\t\t\t\"contextLiterals\": encodedContextLiterals,\n\t\t\t\t\t\t\"literalsActiveEvent\": encodedLiteralsActiveEvent\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// convert sets and maps to arrays\n\t\t\tif (value instanceof Set) {\n\t\t\t\treturn Array.from(value);\n\t\t\t} else if (value instanceof Map) {\n\t\t\t\treturn Array.from(value.entries());\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\treturn JSON.stringify(obj, replacer);\n\t}\n\n\tstatic deserializeAppState(json: string): [number, string, string, Dag] {\n\t\tconst res = JSON.parse(json);\n\t\tassert(res.version !== undefined);\n\t\tassert(res.problem !== undefined);\n\t\tassert(res.vampireUserOptions !== undefined);\n\t\tassert(res.dag !== undefined);\n\n\t\tconst dag = this.reconstructDag(res.dag);\n\n\t\treturn [res.version, res.problem, res.vampireUserOptions, dag];\n\t}\n\n\tstatic reconstructDag(obj): Dag {\n\t\tassert(obj.nodes !== undefined);\n\t\tconst nodes = new Map<number,SatNode>();\n\t\tfor (const pairIdNode of obj.nodes) {\n\t\t\tnodes.set(pairIdNode[0], Serializer.reconstructSatNode(pairIdNode[1]));\n\t\t}\n\t\tconst dag = new Dag(nodes);\n\t\tcomputeParentLiterals(dag); // TODO: hack.\n\n\t\treturn dag;\n\t}\n\t\n\tstatic reconstructSatNode(obj): SatNode {\n\t\tassert(obj.id !== undefined);\n\t\tassert(obj.unit !== undefined);\n\t\tassert(obj.inferenceRule !== undefined);\n\t\tassert(obj.parents !== undefined);\n\t\tassert(obj.statistics !== undefined);\n\t\tassert(obj.isFromPreprocessing !== undefined);\n\t\tassert(obj.newTime !== undefined);\n\t\tassert(obj.activeTime !== undefined);\n\t\tassert(obj.deletionTime !== undefined);\n\t\tassert(obj.deletionParents !== undefined);\n\t\tassert(obj.position !== undefined);\n\t\tassert(obj.isBoundary !== undefined);\n\n\t\tconst unit = Serializer.reconstructUnit(obj.unit);\n\t\tconst statistics = new Map<string,number>();\n\t\tfor (const pair of obj.statistics) {\n\t\t\tstatistics.set(pair[0], pair[1]);\n\t\t}\n\n\t\tconst node = new SatNode(obj.id, unit, obj.inferenceRule, obj.parents, statistics, obj.isFromPreprocessing, obj.newTime, obj.activeTime, obj.deletionTime, obj.deletionParents, obj.isBoundary);\n\t\tnode.position = obj.position;\n\n\t\treturn node;\n\t}\n\n\tstatic reconstructUnit(obj): Unit {\n\t\tassert(obj.type !== undefined);\n\t\tif (obj.type === \"Formula\") {\n\t\t\tassert(obj.formula !== undefined);\n\t\t\treturn new Formula(obj.formula);\n\t\t} else {\n\t\t\tassert(obj.literalsNewEvent !== undefined);\n\t\t\tassert(obj.premiseLiterals !== undefined);\n\t\t\tassert(obj.conclusionLiterals !== undefined);\n\t\t\tassert(obj.contextLiterals !== undefined);\n\t\t\tassert(obj.literalsActiveEvent !== undefined);\n\t\t\t\n\t\t\tconst literalsNewEvent = obj.literalsNewEvent.map(literal => Serializer.reconstructLiteral(literal));\n\t\t\t\n\t\t\t// reconstruct encoded literal-arrays\n\t\t\tconst premiseLiterals = obj.premiseLiterals.map(n => literalsNewEvent[n]);\n\t\t\tconst conclusionLiterals = obj.conclusionLiterals.map(n => literalsNewEvent[n]);\n\t\t\tconst contextLiterals = obj.contextLiterals.map(n => literalsNewEvent[n]);\n\t\t\tconst literalsActiveEvent = obj.literalsActiveEvent === null ? null : obj.literalsActiveEvent.map(n => literalsNewEvent[n]);\n\t\t\t\n\t\t\tconst clause = new Clause(literalsNewEvent, premiseLiterals, conclusionLiterals, contextLiterals);\n\t\t\tclause.literalsActiveEvent = literalsActiveEvent;\n\t\t\treturn clause;\n\t\t}\n\t}\n\n\tstatic reconstructLiteral(obj): Literal {\n\t\tassert(obj.name !== undefined);\n\t\tassert(obj.args !== undefined);\n\t\tassert(obj.negated !== undefined);\n\t\tassert(obj.isSelected !== undefined);\n\t\tassert(obj.representation !== undefined);\n\t\tassert(obj.hideBracketsAssoc !== undefined);\n\t\tassert(obj.nonStrictForNegatedStrictInequalities !== undefined);\n\t\tassert(obj.orientationReason !== undefined);\n\n\t\tconst args = obj.args.map(term => Serializer.reconstructTerm(term));\n\t\t\n\t\tconst literal = new Literal(obj.name, args, obj.negated);\n\t\tliteral.isSelected = obj.isSelected;\n\t\tliteral.representation = obj.representation;\n\t\tliteral.hideBracketsAssoc = obj.hideBracketsAssoc;\n\t\tliteral.nonStrictForNegatedStrictInequalities = obj.nonStrictForNegatedStrictInequalities;\n\t\tliteral.orientationReason = obj.orientationReason;\n\n\t\treturn literal;\n\t}\n\n\tstatic reconstructTerm(obj): Term {\n\t\tassert(obj.name !== undefined);\n\t\tassert(obj.args !== undefined);\n\n\t\tconst args = obj.args.map(term => Serializer.reconstructTerm(term));\n\n\t\treturn new Term(obj.name, args);\n\t}\n}\n","import * as React from 'react';\nimport {Component} from 'react';\n\nimport Main from './Main';\nimport Aside from './Aside';\nimport {Dag, ParsedLine} from '../model/dag';\nimport SatNode from '../model/sat-node';\nimport './App.css';\nimport {assert} from '../model/util';\nimport {filterNonConsequences, filterNonParents, mergePreprocessing} from '../model/transformations';\nimport {findCommonConsequences} from '../model/find-node';\nimport {VizWrapper} from '../model/viz-wrapper';\nimport {Clause} from '../model/unit';\nimport {Literal} from '../model/literal';\nimport {computeClauseRepresentation, computeParentLiterals} from '../model/clause-orientation';\nimport {Serializer} from '../model/serialization';\n\nexport enum AppMode {\n  'proof',\n  'saturation',\n  'manualcs',\n  'saved'\n}\n\ntype Props = {\n  problem: string,\n  loadedProblem?: string,\n  vampireUserOptions: string,\n  mode: AppMode,\n  hideBracketsAssoc: boolean,\n  nonStrictForNegatedStrictInequalities: boolean, \n  orientClauses: boolean,\n  logging: boolean\n};\n\n/* Invariant: the state is always in one of the following phases\n *    \"loaded\": A dag is loaded. Clause selection is not possible. dags, nodeSelection and currentTime hold meaningful values.\n *    \"loaded selected\": Same as \"loaded\", but clause selection is possible.\n *    \"waiting\": Waiting for answer from Vampire server. message holds a meaningful value.\n *    \"layouting\": Layouting a dag. message holds a meaningful value.\n *    \"error\": Some error occured. message holds a meaningful value.\n */\ntype State = {\n  state: \"loaded\" | \"loaded select\" | \"waiting\" | \"layouting\" | \"error\",\n  dags: Dag[],\n  nodeSelection: number[],\n  currentTime: number,\n  animateDagChanges,\n  changedNodesEvent?: Set<number>, // update to trigger refresh of node in graph. Event is of the form [eventId, nodeId]\n  message: string,\n  showPassiveDag: boolean\n  nodeIdToActivate: number | null,\n  infoToggle: boolean,\n  editToggle: boolean\n}\n\nclass App extends Component<Props, State> {\n\n  state: State = {\n    state: \"waiting\",\n    dags: [],\n    nodeSelection: [],\n    currentTime: 0,\n    animateDagChanges: false,\n    changedNodesEvent: undefined,\n    message: \"\",\n    showPassiveDag: false,\n    nodeIdToActivate: null,\n    infoToggle: false,\n    editToggle: false,\n  };\n\n  render() {\n    const {\n      state,\n      dags,\n      nodeSelection,\n      currentTime,\n      animateDagChanges,\n      changedNodesEvent,\n      message,\n      showPassiveDag\n    } = this.state;\n    \n    let dag;\n    let main;\n    if (state === \"loaded\" || state === \"loaded select\") {\n      assert(dags.length > 0);\n      dag = dags[dags.length-1];\n      main = (\n        <Main\n          dag={dag}\n          showPassiveDag={showPassiveDag}\n          nodeSelection={nodeSelection}\n          changedNodesEvent={changedNodesEvent}\n          historyLength={dags[0].maximalActiveTime()}\n          currentTime={currentTime}\n          animateDagChanges={animateDagChanges}\n          infoToggle={this.state.infoToggle}\n          editToggle={this.state.editToggle}\n          readOnly={this.props.mode === AppMode.saved}\n          onNodeSelectionChange={this.updateNodeSelection.bind(this)}\n          onCurrentTimeChange={this.updateCurrentTime.bind(this)}\n          onDismissPassiveDag={this.dismissPassiveDag.bind(this)}\n          onUpdateNodePositions={this.updateNodePositions.bind(this)}\n          onLiteralOrientationChange={this.changeLiteralOrientation.bind(this)}\n          onLiteralRepresentationChange={this.changeLiteralRepresentation.bind(this)}\n          onToggleInfo={this.toggleInfo.bind(this)}\n          onToggleEdit={this.toggleEdit.bind(this)}\n        />\n      );\n    } else {\n      dag = null;\n      main = (\n        <main>\n          <section className=\"graph-placeholder\">{message}</section>\n          <section className=\"slider-placeholder\"/>\n        </main>\n      );\n    }\n\n    return (\n      <div className=\"app\">\n        {main}\n        <Aside\n          dag={dag}\n          currentTime={currentTime}\n          nodeSelection={nodeSelection}\n          multipleVersions={dags.length > 1}\n          infoToggle={this.state.infoToggle}\n          editToggle={this.state.editToggle}\n          readOnly={this.props.mode === AppMode.saved}\n          onUpdateNodeSelection={this.updateNodeSelection.bind(this)}\n          onUndo={this.undoLastStep.bind(this)}\n          onRenderParentsOnly={this.renderParentsOnly.bind(this)}\n          onRenderChildrenOnly={this.renderChildrenOnly.bind(this)}\n          onShowPassiveDag={this.showPassiveDag.bind(this)}\n          onSelectParents={this.selectParents.bind(this)}\n          onSelectChildren={this.selectChildren.bind(this)}\n          onSelectCommonConsequences={this.selectCommonConsequences.bind(this)}\n          onLiteralOrientationChange={this.changeLiteralOrientation.bind(this)}\n          onLiteralRepresentationChange={this.changeLiteralRepresentation.bind(this)}\n          onToggleInfo={this.toggleInfo.bind(this)}\n          onToggleEdit={this.toggleEdit.bind(this)}\n        />\n      </div>\n    );\n\n  }\n\n  async componentDidMount() {\n    if (this.props.mode === AppMode.saved) {\n      // render 'read-only' mode\n      const [, , , dag] = Serializer.deserializeAppState(this.props.loadedProblem || '{}');\n      this.setState({\n        state: 'loaded',\n        dags: [dag],\n        nodeSelection: [],\n        currentTime: dag.maximalActiveTime(),\n        animateDagChanges: false\n      });\n    } else {\n      // call Vampire on given input problem\n      await this.runVampire(this.props.problem, this.props.vampireUserOptions, this.props.mode);\n\n      if (this.state.state === 'loaded select' && this.props.mode === AppMode.manualcs) {\n        this.selectFinalPreprocessingClauses();\n      }\n    }\n  }\n\n  // LOAD AND SAVE /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  serialize(): string {\n    assert(this.state.state === \"loaded\" || this.state.state === \"loaded select\");\n    assert(this.state.dags.length > 0);\n\n    return Serializer.serializeAppState(this.props.problem, this.props.vampireUserOptions, this.state.dags[0]);\n  }\n\n  // NETWORK ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  updateNodeSelection(nodeSelection: number[]) {\n    if (this.props.logging) {\n      console.log(`Updating node selection to [${nodeSelection.toString()}]`);\n    }\n    this.setState({nodeSelection: nodeSelection});\n  }\n\n  updateCurrentTime(currentTime: number) {\n    if (this.props.logging) {\n      console.log(`Updating current time to ${currentTime}`);\n    }\n    const dags = this.state.dags\n    assert(dags.length > 0);\n    const dag = dags[dags.length - 1];\n\n    const nodesInActiveDag = dag.computeNodesInActiveDag(currentTime);\n    const nodeSelection = new Array<number>();\n    for (const nodeId of this.state.nodeSelection) {\n      if (nodesInActiveDag.has(nodeId)) {\n        nodeSelection.push(nodeId);\n      }\n    }\n    this.setState({\n      nodeSelection: nodeSelection,\n      currentTime: currentTime\n    });\n  }\n\n\n  // FILE UPLOAD ///////////////////////////////////////////////////////////////////////////////////////////////////////\n  jsonToParsedLines(json: any): Array<ParsedLine> {\n    const parsedLines = new Array<ParsedLine>();\n    for (const line of json.lines) {\n      const statistics = new Map<string,number>();\n      for (const key in line.statistics) {\n        const val = line.statistics[key];\n        if (typeof val === \"number\"){\n          statistics.set(key, val);\n        }\n      }\n      parsedLines.push(new ParsedLine(line.lineType, line.unitId, line.unitString, line.inferenceRule, line.parents, statistics));\n    }\n    return parsedLines;\n  }\n\n  async runVampire(problem: string, vampireUserOptions: string, mode: AppMode) {\n    assert(mode !== AppMode.saved, 'Saved mode does not require vampire.');\n\n    this.setState({\n      state: \"waiting\",\n      message: \"Waiting for Vampire...\",\n      dags: [],\n      nodeSelection: [],\n      currentTime: 0\n    });\n\n    const url = mode === AppMode.manualcs ? 'http://localhost:5000/vampire/startmanualcs' : 'http://localhost:5000/vampire/start';\n    if (this.props.logging) {\n      console.log(`Starting request to url '${url}' with Vampire-user-options '${vampireUserOptions}'.`);\n    }\n    const fetchedJSON = await fetch(url, {\n      method: 'POST',\n      mode: 'cors',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        file: problem,\n        vampireUserOptions: vampireUserOptions\n      })\n    });\n\n    try {\n      const json = await fetchedJSON.json();\n\n      if (this.props.logging) {\n        console.log(`Received response from Vampire server.`);\n      }\n      if (json.status === \"success\") {\n        assert(json.vampireState === \"running\" ||\n          json.vampireState === \"refutation\" ||\n          json.vampireState === \"saturation\" ||\n          json.vampireState === \"timeout\");\n\n        if (mode === AppMode.proof) {\n          assert(json.vampireState !== \"running\")\n          if (json.vampireState === \"saturation\") {\n            this.setState({\n              state: \"error\",\n              message: \"Saturation: Vampire saturated, so there exists no proof!\",\n              dags: [],\n              nodeSelection: [],\n              currentTime: 0\n            });\n            return;\n          }\n          if (json.vampireState === \"timeout\") {\n            this.setState({\n              state: \"error\",\n              message: \"Timeout: Vampire could not find a proof in the given time!\",\n              dags: [],\n              nodeSelection: [],\n              currentTime: 0\n            });\n            return;\n          }\n        } else {\n          if (json.vampireState === \"saturation\" && json.lines.length === 0) {\n            this.setState({\n              state: \"error\",\n              message: \"The example was already identified to be satisfiable during Vampire's preprocessing.\",\n              dags: [],\n              nodeSelection: [],\n              currentTime: 0\n            });\n            return;\n          }\n        }\n        if (this.props.logging) {\n          console.log(`Constructing Vampire-saturation-events from received JSON.`);\n        }\n        const parsedLines = this.jsonToParsedLines(json);\n\n        if (this.props.logging) {\n          console.log(`Constructing saturation graph from Vampire-saturation-events.`);\n        }\n        let dag = Dag.fromParsedLines(parsedLines, null);\n\n        if (this.props.logging) {\n          console.log(`Merging preprocessing-subgraph of saturation graph.`);\n        }\n        dag = mergePreprocessing(dag);\n\n        if (mode === AppMode.proof) {\n          assert(dag.isRefutation);\n          // find empty clause\n          for (const node of dag.nodes.values()) {\n            if (node.unit.type === \"Clause\") {\n              const clause = node.unit as Clause;\n              if (clause.premiseLiterals.length === 0 && clause.conclusionLiterals.length === 0) {\n\n                // filter all non-parents of empty clause\n                const relevantIds = new Set<number>();\n                relevantIds.add(node.id);\n                dag = filterNonParents(dag, relevantIds);\n                break;\n              }\n            }\n          }\n        }\n        if (this.props.logging) {\n          console.log(`Computing layout for saturation graph.`);\n        }\n        await VizWrapper.layoutDag(dag, true);\n\n        if (this.props.orientClauses) {\n          if (this.props.logging) {\n            console.log(`Computing literal flows for saturation graph.`);\n          }\n          computeParentLiterals(dag);\n          if (this.props.logging) {\n            console.log(`Computing clause representations for saturation graph.`);\n          }\n          computeClauseRepresentation(dag, null);\n        }\n        this.setLiteralOptions(dag);\n\n        const state = (mode === AppMode.manualcs && json.vampireState === \"running\") ? \"loaded select\" : \"loaded\";\n\n        this.setState({\n          state: state,\n          dags: [dag],\n          nodeSelection: [],\n          currentTime: dag.maximalActiveTime(),\n          animateDagChanges: false\n        });\n        if (this.props.logging) {\n          console.log(`Finished preparation of saturation graph.`);\n        }\n      } else {\n        assert(json.status === \"error\");\n        const errorMessage = json.message;\n        assert(errorMessage !== undefined && errorMessage !== null);\n        this.setState({\n          state: \"error\",\n          message: errorMessage,\n          dags: [],\n          nodeSelection: [],\n          currentTime: 0\n        });\n      }\n    } catch (error) {\n      if (error.name === \"SatVisAssertionError\") {\n        throw error;\n      }\n      this.setState({\n        state: \"error\",\n        message: `Error: ${error[\"message\"]}`,\n        dags: [],\n        nodeSelection: [],\n        currentTime: 0\n      });\n    }\n  }\n\n  // select the clause with id 'selectedId', then compute incremental layout for resulting dag\n  async selectClause(selectedId: number, positioningHint: [number, number]) {\n    assert(this.state.dags.length >= 1);\n    const currentDag = this.state.dags[this.state.dags.length-1];\n    const currentDagActiveNodes = currentDag.computeNodesInActiveDag(currentDag.maximalActiveTime()); // needs to be computed before dag is extended, since nodes are shared\n    assert(currentDag.mergeMap !== null);\n\n    // ask server to select clause and await resulting saturation events\n    const url = 'http://localhost:5000/vampire/select';\n    if (this.props.logging) {\n      console.log(`Starting request to url '${url}' with selected-id '${selectedId}'.`);\n    }\n    const fetchedJSON = await fetch(url, {\n      method: 'POST',\n      mode: 'cors',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({id: selectedId})\n    });\n\n    try {\n      const json = await fetchedJSON.json();\n      if (this.props.logging) {\n        console.log(`Received response from Vampire server.`);\n      }\n      if (json.status === \"success\") {\n        if (this.props.logging) {\n          console.log(`Constructing Vampire-saturation-events from received JSON.`);\n        }\n        const parsedLines = this.jsonToParsedLines(json);\n\n        // extend existing dag with new saturation events from server\n        if (this.props.logging) {\n          console.log(`Extending existing saturation graph with Vampire-saturation-events.`);\n        }\n        const newDag = Dag.fromParsedLines(parsedLines, currentDag);\n\n        // compute which nodes have been newly generated\n        const newDagActiveNodes = newDag.computeNodesInActiveDag(newDag.maximalActiveTime());\n        const newNodes = new Map<number, SatNode>();\n        for (const [nodeId, node] of newDag.nodes) {\n          if(!currentDagActiveNodes.has(nodeId) && newDagActiveNodes.has(nodeId)) {\n            newNodes.set(nodeId, node);\n          }\n        }\n\n        if (newNodes.size > 0) {\n          if (this.props.logging) {\n            console.log(`Extending layout to new nodes of saturation graph.`);\n          }\n          await VizWrapper.layoutNodesAtPosition(newNodes, positioningHint);\n        }\n\n        if (this.props.orientClauses) {\n          if (this.props.logging) {\n            console.log(`Updating literal flows for saturation graph.`);\n          }\n          computeParentLiterals(newDag);\n          if (this.props.logging) {\n            console.log(`Updating clause representations for saturation graph.`);\n          }\n          computeClauseRepresentation(newDag, null);\n        }\n        this.setLiteralOptions(newDag);\n  \n        const state = json.vampireState === \"running\" ? \"loaded select\" : \"loaded\";\n        const nodeSelection = new Array<number>();\n        for (const nodeId of newNodes.keys()) {\n          nodeSelection.push(nodeId);\n        }\n        this.setState({\n          state: state,\n          dags: [newDag],\n          nodeSelection: nodeSelection,\n          currentTime: newDag.maximalActiveTime(),\n          animateDagChanges: true\n        });\n        if (this.props.logging) {\n          console.log(`Finished extension of saturation graph.`);\n        }\n      } else {\n        assert(json.status === \"error\");\n        const errorMessage = json.message;\n        assert(errorMessage !== undefined && errorMessage !== null);\n        this.setState({\n          state: \"error\",\n          message: errorMessage,\n          dags: [],\n          nodeSelection: [],\n          currentTime: 0\n        });\n      }\n    } catch (error) {\n      if (error.name === \"SatVisAssertionError\") {\n        throw error;\n      }\n      this.setState({\n        state: \"error\",\n        message: `Error: ${error[\"message\"]}`,\n        dags: [],\n        nodeSelection: [],\n        currentTime: 0\n      });\n    }\n  }\n\n  async selectFinalPreprocessingClauses() {\n    if (this.props.logging) {\n      console.log(`Starting to select all clauses from preprocessing.`);\n    }\n    // iterate as long as the server waits for clause selections and as long as a suitable clause is found\n    let stop = false;\n    while (this.state.state === \"loaded select\" && !stop) {\n      const dag = this.state.dags[0];\n\n      // find a final preprocessing clause which can be selected\n      stop = true;\n      for (const [nodeId, node] of dag.nodes) {\n        if (node.isFromPreprocessing && node.newTime !== null) {\n          if (node.activeTime === null && node.deletionTime === null) {\n            // select that clause\n            assert(node.position !== null);\n            await this.selectClause(nodeId, node.position as [number, number]);\n            stop = false;\n            break;\n          }\n        }\n      }\n    }\n    if (this.props.logging) {\n      console.log(`Finished to select all clauses from preprocessing.`);\n    }\n  }\n\n  // SUBGRAPH SELECTION ////////////////////////////////////////////////////////////////////////////////////////////////\n\n  undoLastStep() {\n    if (this.props.logging) {\n      console.log(`Pop last saturation graph from the stack.`);\n    }\n    this.popDag();\n  }\n\n  async renderParentsOnly() {\n    const {dags, nodeSelection} = this.state;\n    const currentDag = dags[dags.length - 1];\n\n    if (this.props.logging) {\n      console.log(`Generate saturation graph which consists only of the (transitive) parents of clauses [${nodeSelection}].`);\n    }\n    const newDag = filterNonParents(currentDag, new Set(nodeSelection));\n    if (this.props.logging) {\n      console.log(`Computing layout for new saturation graph.`);\n    }\n    await VizWrapper.layoutDag(newDag, true);\n\n    if (this.props.logging) {\n      console.log(`Finished preparation of new saturation graph. Pushing it to the stack.`);\n    }\n    this.pushDag(newDag);\n  }\n\n  async renderChildrenOnly() {\n    const {dags, nodeSelection} = this.state;\n    const currentDag = dags[dags.length - 1];\n\n    if (this.props.logging) {\n      console.log(`Generate saturation graph which consists only of the (transitive) children of clauses [${nodeSelection}].`);\n    }\n    const newDag = filterNonConsequences(currentDag, new Set(nodeSelection));\n    if (this.props.logging) {\n      console.log(`Computing layout for new saturation graph.`);\n    }\n    await VizWrapper.layoutDag(newDag, true);\n\n    if (this.props.logging) {\n      console.log(`Finished preparation of new saturation graph. Pushing it to the stack.`);\n    }\n    this.pushDag(newDag);\n  }\n\n  // PASSIVE DAG ////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  async showPassiveDag() {\n    assert(this.state.showPassiveDag === false);\n    assert(this.state.nodeSelection.length > 0);\n\n    if (this.props.logging) {\n      console.log(`Display selection graph containing all clauses which can be selected for activation and whose derivation contains all the clauses [${this.state.nodeSelection}].`);\n    }\n    this.setState({showPassiveDag: true});\n  }\n\n  async dismissPassiveDag(selectedId: number | null, positioningHint: [number, number] | null) {\n    assert((selectedId === null) === (positioningHint === null));\n    assert(this.state.showPassiveDag === true);\n\n    // remove passive dag\n    this.setState({ showPassiveDag: false});\n\n    if (selectedId !== null) {\n      // switch from currentDag to dag resulting from selecting nodeIdToActivate\n      if (this.props.logging) {\n        console.log(`Removing selection graph. Clause ${selectedId} was selected.`);\n      }\n      await this.selectClause(selectedId, positioningHint!);\n    } else {\n      if (this.props.logging) {\n        console.log(`Removing selection graph. No clause was selected.`);\n      }\n    }\n  }\n\n\n  // NODE SELECTION ////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  selectParents() {\n    const {dags, nodeSelection, currentTime} = this.state;\n    const currentDag = dags[dags.length - 1];\n    const nodesInActiveDag = currentDag.computeNodesInActiveDag(currentTime);\n\n    const newSelection = new Set(nodeSelection);\n    for (const nodeId of nodeSelection) {\n      assert(nodesInActiveDag.has(nodeId));\n      for (const parentId of currentDag.get(nodeId).parents) {\n        if(nodesInActiveDag.has(parentId)) {\n          newSelection.add(parentId);\n        }\n      }\n    }\n\n    this.updateNodeSelection(Array.from(newSelection));\n  }\n\n  selectChildren() {\n    const {dags, nodeSelection, currentTime} = this.state;\n    const currentDag = dags[dags.length - 1];\n    const nodesInActiveDag = currentDag.computeNodesInActiveDag(currentTime);\n\n    const newSelection = new Set(nodeSelection);\n    for (const nodeId of nodeSelection) {\n      assert(nodesInActiveDag.has(nodeId));\n      for (const childId of currentDag.getChildren(nodeId)) {\n        if(nodesInActiveDag.has(childId)) {\n          newSelection.add(childId);\n        }\n      }\n    }\n    this.updateNodeSelection(Array.from(newSelection));\n  }\n\n  selectCommonConsequences() {\n    const {dags, nodeSelection, currentTime} = this.state;\n    const currentDag = dags[dags.length - 1];\n    const nodesInActiveDag = currentDag.computeNodesInActiveDag(currentTime);\n\n    const commonConsequences = findCommonConsequences(currentDag, new Set(nodeSelection));\n    const newSelection = new Array<number>();\n    for (const nodeId of commonConsequences) {\n      if (nodesInActiveDag.has(nodeId)) {\n        newSelection.push(nodeId);\n      }\n    }\n    this.updateNodeSelection(newSelection);\n  }\n\n  // LITERALS ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  private changeLiteralOrientation(nodeId: number, oldPosition: [\"premise\" | \"conclusion\" | \"context\", number], newPosition: [\"premise\" | \"conclusion\" | \"context\", number]) {\n    const dags = this.state.dags;\n    assert(dags.length > 0);\n    const dag = dags[0];\n    const node = dag.nodes.get(nodeId);\n    assert(node !== undefined);\n    assert(node!.unit.type === \"Clause\");\n    const clause = node!.unit as Clause;\n\n    clause.changeLiteralOrientation(oldPosition, newPosition);\n\n    const changedNodes = computeClauseRepresentation(dag, nodeId);\n    \n    this.setState({changedNodesEvent: changedNodes});\n  }\n\n  private changeLiteralRepresentation(nodeId: number, literal: Literal) {\n    const dags = this.state.dags;\n    assert(dags.length > 0);\n    const dag = dags[0];\n    const node = dag.nodes.get(nodeId);\n    assert(node !== undefined);\n\n    literal.switchToNextRepresentation();\n    \n    const changedNodes = computeClauseRepresentation(dag, nodeId);\n\n    this.setState({changedNodesEvent: changedNodes});\n  }\n\n  // HELPERS ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  updateNodePositions(nodeIds: Array<number>, delta: [number, number]) {\n    const dags = this.state.dags\n    assert(this.state.dags.length > 0);\n    const dag = dags[dags.length - 1];\n    for (const nodeId of nodeIds) {\n      const node = dag.get(nodeId);\n      assert(node.position !== null);\n      node.position = [node.position![0] + delta[0], node.position![1] + delta[1]];\n    }\n  }\n\n  // push a new dag on the stack of dags\n  // Precondition: the layout for newDag has already been computed\n  private pushDag(newDag: Dag) {\n    assert(!newDag.isPassiveDag);\n\n    const {dags, nodeSelection} = this.state;\n    \n    // filter out selected nodes which don't occur in new graph\n    const selectedNodesInNewDag = new Array<number>();\n    for (const nodeId of nodeSelection) {\n      if (newDag.nodes.has(nodeId)) {\n        selectedNodesInNewDag.push(nodeId);\n      }\n    }\n\n    this.setState({\n      dags: dags.concat([newDag]),\n      nodeSelection: selectedNodesInNewDag,\n      animateDagChanges: false\n    });\n  }\n\n  private popDag() {\n    assert(this.state.dags.length > 1, \"Undo last step must only be called if there exist at least two dags\");\n\n    this.setState((state, props) => ({\n      dags: state.dags.slice(0, state.dags.length-1),\n      animateDagChanges: false\n    }));\n  }\n\n  setLiteralOptions(dag: Dag) {\n    const hideBracketsAssoc = this.props.hideBracketsAssoc;\n    const nonStrictForNegatedStrictInequalities = this.props.nonStrictForNegatedStrictInequalities;\n\n    for (const node of dag.nodes.values()) {\n      if (node.unit.type === \"Clause\") {\n        const clause = node.unit as Clause;\n        for (const literal of clause.premiseLiterals) {\n          literal.hideBracketsAssoc = hideBracketsAssoc;\n          literal.nonStrictForNegatedStrictInequalities = nonStrictForNegatedStrictInequalities;\n        }\n        for (const literal of clause.conclusionLiterals) {\n          literal.hideBracketsAssoc = hideBracketsAssoc;\n          literal.nonStrictForNegatedStrictInequalities = nonStrictForNegatedStrictInequalities;\n        }\n      }\n    }\n  }\n\n  // STATE TOGGLE //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  toggleInfo() {\n    this.setState({ infoToggle: !this.state.infoToggle });\n  }\n\n  toggleEdit() {\n    this.setState({ editToggle: !this.state.editToggle });\n  }\n}\n\nexport default App;\n","import { Dag } from \"./dag\";\nimport { DFPostOrderTraversal } from \"./traversal\";\n\n// return ids of nodes, which have a derivation where each of the nodes in relevantIds occurs\nexport function findCommonConsequences(dag: Dag, relevantIds: Set<number>): Array<number> {\n\n\t// want to compute common consequences\n\tconst commonConsequences = new Array<number>();\n\n\t// create dictionary which maps the id of each node to the subset of relevantIds occuring in the derivation of the node\n\tconst idToRelevantParentIds = new Map<number, Set<number>>();\n\n\t// add all transitive children of ids in transitiveChildren to transitiveChildren\n\tconst iterator = new DFPostOrderTraversal(dag);\n\twhile (iterator.hasNext()) {\n\t\tconst currentNode = iterator.getNext();\n\t\tconst currentNodeId = currentNode.id;\n\n\t\tconst relevantParents = new Set<number>();\n\t\t// compute relevant parents and update dictionary\n\t\tif (relevantIds.has(currentNodeId)) {\n\t\t\trelevantParents.add(currentNodeId);\n\t\t}\n\t\tfor (const parentId of currentNode.parents) {\n\t\t\tconst relevantParentIdsFromParent = idToRelevantParentIds.get(parentId) as Set<number>;\n\t\t\t// merge relevantParentIdsFromParent into relevantParents\n\t\t\tfor (const relevantParentId of relevantParentIdsFromParent) {\n\t\t\t\trelevantParents.add(relevantParentId);\n\t\t\t}\n\t\t}\n\t\tidToRelevantParentIds.set(currentNodeId, relevantParents);\n\n\t\t// check whether each relevant id occurs in relevant parents\n\t\tif (relevantIds.size === relevantParents.size) {\n\t\t\tcommonConsequences.push(currentNodeId);\n\t\t}\n\t}\n\t\n\treturn commonConsequences;\n}","import * as React from 'react';\nimport {NavigationBar} from './NavigationBar';\nimport App, {AppMode} from './App';\nimport './AppWrapper.css';\n\ntype Props = {\n  name: string,\n  problem: string,\n  loadedProblem?: string,\n  loadedProblemName?: string,\n  vampireUserOptions: string,\n  mode: AppMode,\n  hideBracketsAssoc: boolean,\n  nonStrictForNegatedStrictInequalities: boolean,\n  orientClauses: boolean,\n  logging: boolean\n};\n\nexport class AppWrapper extends React.Component<Props, {}> {\n\n  private app = React.createRef<App>();\n\n  render() {\n    return (\n      <div id=\"appWrapper\">\n        <NavigationBar\n          name={this.props.mode === AppMode.saved ? `${this.props.loadedProblemName} (read-only)` : this.props.name}\n          onSave={() => this.save()}\n        />\n        <App ref={this.app}\n             problem={this.props.problem}\n             loadedProblem={this.props.loadedProblem}\n             vampireUserOptions={this.props.vampireUserOptions}\n             mode={this.props.mode}\n             hideBracketsAssoc={this.props.hideBracketsAssoc}\n             nonStrictForNegatedStrictInequalities={this.props.nonStrictForNegatedStrictInequalities}\n             orientClauses={this.props.orientClauses}\n             logging={this.props.logging}\n        />\n      </div>\n    )\n  }\n\n  save() {\n    if (!this.app.current) {\n      return;\n    }\n    const saveData = this.app.current.serialize();\n    const element = document.createElement('a');\n    const file = new Blob([saveData], {type: 'text/plain'});\n    element.href = URL.createObjectURL(file);\n    element.download = this.generateFilename();\n    document.body.appendChild(element);\n    element.click();\n  }\n\n  private generateFilename(): string {\n    const prefix = (this.props.name || '').split('.')[0];\n    return `${prefix || 'satvis'}-saved.txt`\n  }\n\n}\n\n  ","import * as React from 'react';\nimport {useHistory} from 'react-router-dom';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\nexport default function LoadSavedProblemButton(props) {\n  const history = useHistory();\n  const fileUpload = React.createRef<HTMLInputElement>();\n\n  function loadSavedProblemData(event: React.ChangeEvent<HTMLInputElement>) {\n    if (event.target.files !== null && event.target.files.length > 0) {\n      const file = event.target.files[0];\n      const reader = new FileReader();\n      // callback which will be executed when readAsText is called\n      reader.onloadend = () => {\n        const text = (reader.result ? reader.result : '') as string;\n        props.onLoadSavedProblemData(text, file.name);\n        history.push('/saved/');\n      };\n      reader.readAsText(file);\n    }\n  }\n\n  return (\n    <section className=\"load-component\">\n      <button\n        className=\"load-button\"\n        type=\"button\"\n        onClick={() => fileUpload.current && fileUpload.current.click()}>\n        <svg viewBox=\"0 0 24 24\" className=\"icon\">\n          <use xlinkHref={`${icons}#save-upload`}/>\n        </svg>\n        <span>Load saved proof</span>\n      </button>\n      <input\n        ref={fileUpload}\n        type=\"file\"\n        onChange={loadSavedProblemData}\n      />\n    </section>\n  );\n}\n","import * as React from 'react';\nimport {Link} from 'react-router-dom';\nimport './Menu.css';\nimport * as Monaco from 'monaco-editor'\nimport {assert} from '../model/util';\nimport LoadSavedProblemButton from './LoadSavedProblemButton';\n\nconst icons = require('../resources/icons/all.svg') as string;\n\ntype Props = {\n  problem: string,\n  problemName: string,\n  inputSyntax: 'smtlib' | 'tptp',\n  vampireUserOptions: string,\n  hideBracketsAssoc: boolean,\n  nonStrictForNegatedStrictInequalities: boolean,\n  orientClauses: boolean,\n  logging: boolean,\n  onChangeProblem: (problem: string) => void,\n  onChangeProblemName: (problemName: string) => void,\n  onChangeInputSyntax: (syntax: 'smtlib' | 'tptp') => void\n  onChangeVampireUserOptions: (vampireUserOptions: string) => void,\n  onChangeHideBracketsAssoc: (newValue: boolean) => void,\n  onChangeNonStrictForNegatedStrictInequalities: (newValue: boolean) => void,\n  onChangeOrientClauses: (newValue: boolean) => void,\n  onChangeLogging: (newValue: boolean) => void,\n  onLoadSavedProblemData: (problemData: string, filename: string) => void\n}\n\nexport class Menu extends React.Component<Props, {}> {\n  private isChromeOrFirefox = navigator.userAgent.indexOf('Chrome') > -1 || navigator.userAgent.indexOf('Firefox') > -1;\n  private fileUpload = React.createRef<HTMLInputElement>();\n  monacoDiv = React.createRef<HTMLDivElement>();\n  monaco: Monaco.editor.IStandaloneCodeEditor | null = null\n\n  componentDidMount() {\n    if (!this.isChromeOrFirefox) {\n      return;\n    }\n    // generate instance of Monaco Editor\n    this.monaco = Monaco.editor.create(this.monacoDiv.current!, {\n      lineNumbers: 'off',\n      roundedSelection: false,\n      scrollBeyondLastLine: false,\n      scrollBeyondLastColumn: 0,\n      minimap: {\n        enabled: false\n      },\n      renderLineHighlight: 'none',\n      hideCursorInOverviewRuler: true,\n      links: false,\n      overviewRulerBorder: false,\n      automaticLayout: true,\n      lineDecorationsWidth: 0,\n      lineNumbersMinChars: 0,\n      wordWrap: 'wordWrapColumn'\n      // fontFamily: \"Monaco\" TODO: decide which font to use. By default, multiple fonts are loaded, which is quite slow\n    });\n    this.monaco.setValue(this.props.problem);\n    this.monaco.getModel()!.onDidChangeContent(() => {\n      this.props.onChangeProblem(this.monaco!.getModel()!.getValue());\n    });\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    assert(this.isChromeOrFirefox);\n    if (this.props.problem !== prevProps.problem) {\n      this.monaco!.setValue(this.props.problem);\n    }\n  }\n\n  render() {\n    if (!this.isChromeOrFirefox) {\n      return (\n        <section className=\"unsupported-message\">\n          <svg viewBox=\"0 0 24 24\" className=\"icon\">\n            <use xlinkHref={`${icons}#alert-triangle`}/>\n          </svg>\n          <span>Your current browser is not supported. Please use Chrome or Firefox!</span>\n        </section>\n      );\n    }\n\n    return (\n      <section className=\"component-menu\">\n        <h1>Vampire Saturation Visualization</h1>\n\n        <section className=\"editor\">\n          <div className=\"editor-spacer\">\n            <main>\n              <div className=\"headline-wrapper\">\n                <h2>Input</h2>\n                <small className=\"file-name\">{this.props.problemName}</small>\n                <button title=\"Pick a new file\" onClick={this.chooseFile.bind(this)}>\n                  <svg viewBox=\"0 0 24 24\" className=\"icon big\">\n                    <use xlinkHref={`${icons}#graph-upload`}/>\n                  </svg>\n                </button>\n              </div>\n\n              <input\n                ref={this.fileUpload}\n                type=\"file\"\n                onChange={this.uploadEncoding.bind(this)}\n              />\n              <div ref={this.monacoDiv} className=\"monaco\"></div>\n            </main>\n\n            <aside>\n              <fieldset className=\"options-card\">\n                <h3>Vampire Options</h3>\n                <ul>\n                  <li>\n                    <label htmlFor=\"inputSyntax\" className=\"form-label\">Input language</label>\n                    <select id=\"inputSyntax\" onChange={this.changeInputSyntax.bind(this)}\n                            value={this.props.inputSyntax}>\n                      <option value=\"smtlib\">SMTLIB</option>\n                      <option value=\"tptp\">TPTP</option>\n                    </select>\n                  </li>\n                  <li>\n                    <label htmlFor=\"userOptions\" className=\"form-label\">Additional Vampire options</label>\n                    <input id=\"userOptions\" type=\"text\" onChange={this.changeVampireUserOptions.bind(this)}\n                           value={this.props.vampireUserOptions}>\n                    </input>\n                  </li>\n                </ul>\n              </fieldset>\n\n              <fieldset className=\"options-card\">\n                <h3>Visualization Options</h3>\n                <ul>\n                  <li>\n                    <label>\n                      <input\n                        type=\"checkbox\"\n                        checked={this.props.hideBracketsAssoc}\n                        onChange={this.changeHideBracketsAssoc.bind(this)}/>\n                      Hide brackets for associative operators\n                    </label>\n                  </li>\n                  <li>\n                    <label>\n                      <input\n                        type=\"checkbox\"\n                        checked={this.props.nonStrictForNegatedStrictInequalities}\n                        onChange={this.changeNonStrictForNegatedStrictInequalities.bind(this)}/>\n                      Show negated strict inequalities as (positive) nonstrict inequalities\n                    </label>\n                  </li>\n                  <li>\n                    <label>\n                      <input\n                        type=\"checkbox\"\n                        checked={this.props.orientClauses}\n                        onChange={this.changeOrientClauses.bind(this)}/>\n                      Heuristically orient clauses\n                    </label>\n                  </li>\n                  <li>\n                    <label>\n                      <input\n                        type=\"checkbox\"\n                        checked={this.props.logging}\n                        onChange={this.changeLogging.bind(this)}/>\n                      Logging enabled\n                    </label>\n                  </li>\n                </ul>\n              </fieldset>\n\n              <div className=\"run-options\">\n                <Link to=\"/proof/\" className=\"fake-button\">Find proof</Link>\n                <Link to=\"/saturation/\" className=\"fake-button\">Find saturation</Link>\n                <Link to=\"/manualcs/\" className=\"fake-button\">Start manual clause selection</Link>\n              </div>\n            </aside>\n          </div>\n        </section>\n\n        <LoadSavedProblemButton onLoadSavedProblemData={this.props.onLoadSavedProblemData}/>\n      </section>\n    );\n  }\n\n  chooseFile() {\n    if (this.fileUpload.current) {\n      this.fileUpload.current.click();\n    }\n  }\n\n  uploadEncoding(event: React.ChangeEvent<HTMLInputElement>) {\n    if (event.target.files !== null && event.target.files.length > 0) {\n      const file = event.target.files[0];\n\n      const reader = new FileReader();\n      // callback which will be executed when readAsText is called\n      reader.onloadend = () => {\n        const text = (reader.result ? reader.result : '') as string;\n        this.props.onChangeProblem(text);\n        this.props.onChangeProblemName(file.name);\n\n        // guess inputSyntax from file extension:\n        if (file.name.endsWith('.smt') || file.name.endsWith('.smtlib') || file.name.endsWith('.smt2') || file.name.endsWith('.smtlib2')) {\n          this.props.onChangeInputSyntax('smtlib');\n        } else if (file.name.endsWith('.tptp')) {\n          this.props.onChangeInputSyntax('tptp');\n        }\n      };\n      reader.readAsText(file);\n    }\n  }\n\n  changeVampireUserOptions(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.value;\n    this.props.onChangeVampireUserOptions(newValue);\n  }\n\n  changeTextArea(event: React.ChangeEvent<HTMLTextAreaElement>) {\n    const newValue = event.target.value;\n    this.props.onChangeProblem(newValue);\n  }\n\n  changeHideBracketsAssoc(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.checked;\n    this.props.onChangeHideBracketsAssoc(newValue);\n  }\n\n  changeNonStrictForNegatedStrictInequalities(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.checked;\n    this.props.onChangeNonStrictForNegatedStrictInequalities(newValue);\n  }\n\n  changeInputSyntax(event: React.ChangeEvent<HTMLSelectElement>) {\n    const newValue = event.target.value as 'smtlib' | 'tptp';\n    this.props.onChangeInputSyntax(newValue);\n  }\n\n  changeOrientClauses(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.checked;\n    this.props.onChangeOrientClauses(newValue);\n  }\n\n  changeLogging(event: React.ChangeEvent<HTMLInputElement>) {\n    const newValue = event.target.checked;\n    this.props.onChangeLogging(newValue);\n  }\n}\n","import * as React from 'react';\nimport {HashRouter, Route} from 'react-router-dom';\nimport {AppWrapper} from './AppWrapper'\nimport {Menu} from './Menu'\nimport {AppMode} from './App';\n\ntype State = {\n\tproblem: string,\n\tproblemName: string,\n\tinputSyntax: \"smtlib\" | \"tptp\",\n\tvampireUserOptions: string,\n\thideBracketsAssoc: boolean,\n\tnonStrictForNegatedStrictInequalities: boolean,\n\torientClauses: boolean,\n\tlogging: boolean,\n\tloadedProblem?: string,\n\tloadedProblemName?: string\n}\n\nexport class AppRouter extends React.Component<{}, State> {\n\n\tstate: State = {\n\t\tproblem: \"\",\n\t\tproblemName: \"\",\n\t\tinputSyntax: \"smtlib\",\n\t\tvampireUserOptions: \"\",\n\t\thideBracketsAssoc: true,\n\t\tnonStrictForNegatedStrictInequalities: true,\n\t\torientClauses: true,\n\t\tlogging: false\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<HashRouter>\n\t\t\t\t<Route path=\"/\" exact render={() => \n\t\t\t\t\t<Menu \n\t\t\t\t\t\tproblem={this.state.problem}\n\t\t\t\t\t\tproblemName={this.state.problemName}\n\t\t\t\t\t\tinputSyntax={this.state.inputSyntax}\n\t\t\t\t\t\tvampireUserOptions={this.state.vampireUserOptions}\n\t\t\t\t\t\thideBracketsAssoc={this.state.hideBracketsAssoc}\n\t\t\t\t\t\tnonStrictForNegatedStrictInequalities={this.state.nonStrictForNegatedStrictInequalities}\n\t\t\t\t\t\torientClauses={this.state.orientClauses}\n\t\t\t\t\t\tlogging={this.state.logging}\n\t\t\t\t\t\tonChangeProblem={this.changeProblem.bind(this)}\n\t\t\t\t\t\tonChangeProblemName={this.changeProblemName.bind(this)}\n\t\t\t\t\t\tonChangeInputSyntax={this.changeInputSyntax.bind(this)}\n\t\t\t\t\t\tonChangeVampireUserOptions={this.changeVampireUserOptions.bind(this)}\n\t\t\t\t\t\tonChangeHideBracketsAssoc={this.changeHideBracketsAssoc.bind(this)}\n\t\t\t\t\t\tonChangeNonStrictForNegatedStrictInequalities={this.changeNonStrictForNegatedStrictInequalities.bind(this)}\n\t\t\t\t\t\tonChangeOrientClauses={this.changeOrientClauses.bind(this)}\n\t\t\t\t\t\tonChangeLogging={this.changeLogging.bind(this)}\n\t\t\t\t\t\tonLoadSavedProblemData={this.loadSavedProblem.bind(this)}\n\t\t\t\t\t/>\n\t\t\t\t}/>\n\t\t\t\t<Route path=\"/proof/\" render={() => \n\t\t\t\t\tthis.appComponent(AppMode.proof)\n\t\t\t\t}/>\n\t\t\t\t<Route path=\"/saturation/\" render={() => \n\t\t\t\t\tthis.appComponent(AppMode.saturation)\n\t\t\t\t}/>\n\t\t\t\t<Route path=\"/manualcs/\" render={() => \n\t\t\t\t\tthis.appComponent(AppMode.manualcs)\n\t\t\t\t}/>\n        <Route path=\"/saved/\" render={() =>\n          this.appComponent(AppMode.saved)\n        }/>\n\t\t\t</HashRouter>\n\t\t);\n\t}\n\n\tappComponent(mode: AppMode) {\n\t\tconst inputSyntax = this.state.inputSyntax === \"smtlib\" ? \"smtlib2\" : this.state.inputSyntax;\n\t\tconst vampireUserOptions = `${this.state.vampireUserOptions} --input_syntax ${inputSyntax}`;\n\n\t\treturn <AppWrapper\n\t\t\tname={this.state.problemName}\n\t\t\tmode={mode}\n\t\t\tproblem={this.state.problem}\n\t\t\tloadedProblem={this.state.loadedProblem}\n\t\t\tloadedProblemName={this.state.loadedProblemName}\n\t\t\tvampireUserOptions={vampireUserOptions}\n\t\t\thideBracketsAssoc={this.state.hideBracketsAssoc}\n\t\t\tnonStrictForNegatedStrictInequalities={this.state.nonStrictForNegatedStrictInequalities}\n\t\t\torientClauses={this.state.orientClauses}\n\t\t\tlogging={this.state.logging}\n\t\t/>\n\t}\n\n\tchangeProblem(problem: string) {\n\t\tthis.setState({problem: problem});\n\t}\n\tchangeProblemName(problemName: string) {\n\t\tthis.setState({problemName: problemName});\n\t}\n\tchangeVampireUserOptions(vampireUserOptions: string) {\n\t\tthis.setState({vampireUserOptions: vampireUserOptions});\n\t}\n\tchangeHideBracketsAssoc(newValue: boolean) {\n\t\tthis.setState({hideBracketsAssoc: newValue});\n\t}\n\tchangeNonStrictForNegatedStrictInequalities(newValue: boolean) {\n\t\tthis.setState({nonStrictForNegatedStrictInequalities: newValue});\n\t}\n\tchangeInputSyntax(inputSyntax: \"smtlib\" | \"tptp\") {\n\t\tthis.setState({inputSyntax: inputSyntax});\n\t}\n\tchangeOrientClauses(newValue: boolean) {\n\t\tthis.setState({orientClauses: newValue});\n\t}\n\tchangeLogging(newValue: boolean) {\n\t\tthis.setState({logging: newValue});\n\t}\n\n\tloadSavedProblem(problemData: string, filename: string) {\n\t\tthis.setState({loadedProblem: problemData, loadedProblemName: filename})\n\t}\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport './index.css';\nimport { AppRouter } from './components/Router';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <AppRouter/>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}