import SatNode from './sat-node';
import { assert } from './util';

export default class Dag {

  // TODO: it seems that the result of Graphviz depends on the order of node- and edge declarations.
  //       the order of these declarations depends on the order in which the nodes occur in the nodes-Map.
  //       therefore it could make sense to normalize the order of nodes in the nodes-Map at construction time of the Dag.
  readonly nodes: Map<number,SatNode>;
  readonly leaves: Set<number>;

  constructor(nodes: Map<number,SatNode>) {
    this.nodes = nodes;

    // sanity check: each parentId needs to occur in the derivation as node
    for (const [nodeId, node] of nodes) {
      for (const parentId of node.parents) {
        assert(nodes.has(parentId), `node ${nodeId} has parent ${parentId} which does not occur as node in the dag!`);
      }
    }
    // compute leaves
    const leaves: Set<number> = new Set();
    const nonLeaves: Set<number> = new Set();
    
    for (const node of nodes.values()) {
      for (const parentId of node.parents) {
        nonLeaves.add(parentId);
      }
    }

    for (const nodeId of nodes.keys()) {
      if(!nonLeaves.has(nodeId)) {
        leaves.add(nodeId);
      }
    }

    this.leaves = leaves;
  }

  get(nodeId: number): SatNode {
    assert(this.nodes.has(nodeId), "node doesn't occur in Dag");
    return this.nodes.get(nodeId) as SatNode;
  }

  numberOfHistorySteps(): number {
    let counter = 0;
    for (const node of this.nodes.values()) {
      if (node.activeTime !== null) {
        counter += 1;
      }
    }
    return counter;
  }

  isEmpty(): boolean {
    return this.nodes.size === 0;
  }

  getChildren(nodeId: number): Array<number> {
    if(!this.nodes.has(nodeId)) {
      assert(false, "Node with id " + nodeId + " does not occur in Dag");
    }

    const children = new Array<number>();
    for (const node of this.nodes.values()) {
      for (const parentId of node.parents) {
        if (parentId === nodeId) {
          children.push(node.id);
        }
      }
    }
    return children;
  }

  /* we can partition all nodes of the derivation into three sets
   * 1) inputNodes: the nodes given to Vampire's preprocessing as input
   * 2) preprocessingResultNodes: the nodes remaining at the end of Vampire's preprocessing, (which are then used as input for saturation)
   * 3) otherNodes: the nodes generated by saturation
   *
   * this function decides for a given node whether it should be treated as input node, using the following idea:
   * 1) input nodes occur before saturation is started and are therefore tagged with "isFromPreprocessing"
   * 2) in order to distinguish inputNodes from preprocessingResultNodes:
   *    - if node has a parent, it must be a preprocessingResultNode
   *    - if node has no parent, but a child which is not tagged "isFromPreprocessing", it must be a preprocessingResultNode (e.g. an internally added theory axiom)
   *    - otherwise assume it is an input node
   *    - if a node has no parents (as done for e.g. internal theory axioms), and if it has no children (which should happen rarily, in particular not for theory axioms),
   *      then this could wrongly classify a preprocessingResultNode as inputNode.
   */ 
  nodeIsInputNode(nodeId: number): boolean {
    assert(this.nodes.has(nodeId), "node doesn't occur in Dag");
    const node = this.get(nodeId);

    if (!node.isFromPreprocessing) {
      return false;
    }
    if(node.parents.length > 0) {
      return false;
    }
    const childrenIds = this.getChildren(nodeId);
    for (const childId of childrenIds) {
      const childNode = this.get(childId);
      if (!childNode.isFromPreprocessing) {
        return false;
      }
    }
    return true;
  }

  static fromSetOfNodes(nodes: Set<SatNode>): Dag {
    const nodeDict = new Map<number,SatNode>();
    for (const node of nodes) {
      nodeDict.set(node.id,node);
    }
    return new Dag(nodeDict);
  }

  static fromDto(dto: any): Dag {
    const nodeDict = new Map<number,SatNode>();

    Object.values(dto.nodes).forEach((node: any) => nodeDict.set(node.number, SatNode.fromDto(node)));
    return new Dag(nodeDict);
  }

}
