import SatNode from './sat-node';
import { assert } from './util';
import { UnitParser } from './unit-parser';
import { ReversePostOrderTraversal } from "./traversal";

export class ParsedLine {
  readonly type: "preprocessing" | "new" | "passive" | "active" | "forward reduce" | "backward reduce" | "replaced by" | "using";
  readonly id: number;
  readonly unitString: string;
  readonly inferenceRule: string;
  readonly parents: Array<number>;
  readonly statistics: Map<any, any>; 

  constructor(type: "preprocessing" | "new" | "passive" | "active" | "forward reduce" | "backward reduce" | "replaced by" | "using", id: number, unitString: string, inferenceRule: string, parents: Array<number>, statistics: Map<any, any>) {
    this.type = type;
    this.id = id;
    this.unitString = unitString;
    this.inferenceRule = inferenceRule;
    this.parents = parents;
    this.statistics = statistics;
  }
}

export class Dag {

  // TODO: it seems that the result of Graphviz depends on the order of node- and edge declarations.
  //       the order of these declarations depends on the order in which the nodes occur in the nodes-Map.
  //       therefore it could make sense to normalize the order of nodes in the nodes-Map at construction time of the Dag.
  readonly nodes: Map<number,SatNode>;
  readonly leaves: Set<number>;
  
  // invar: if isPassiveDag, then styleMap !== null
  readonly isPassiveDag: boolean;
  readonly styleMap: Map<number, "passive" | "deleted" | "boundary"> | null;

  constructor(nodes: Map<number,SatNode>, isPassiveDag: boolean = false, styleMap: Map<number, "passive" | "deleted" | "boundary"> | null = null) {
    this.nodes = nodes;

    assert(!isPassiveDag || styleMap !== null)
    this.isPassiveDag = isPassiveDag;
    this.styleMap = styleMap;

    // sanity check: key and id of node need to match
    for (const [nodeId, node] of nodes) {
      assert(nodeId === node.id, `key ${nodeId} and id ${node.id} of node ${node} don't match!`);
    }

    // sanity check: each parentId needs to occur in the derivation as node
    for (const [nodeId, node] of nodes) {
      for (const parentId of node.parents) {
        assert(nodes.has(parentId), `node ${nodeId} has parent ${parentId} which does not occur as node in the dag!`);
      }
    }
    // compute leaves
    const leaves: Set<number> = new Set();
    const nonLeaves: Set<number> = new Set();
    
    for (const node of nodes.values()) {
      for (const parentId of node.parents) {
        nonLeaves.add(parentId);
      }
    }

    for (const nodeId of nodes.keys()) {
      if(!nonLeaves.has(nodeId)) {
        leaves.add(nodeId);
      }
    }

    this.leaves = leaves;
  }

  get(nodeId: number): SatNode {
    const node = this.nodes.get(nodeId);
    assert(node !== undefined, "node doesn't occur in Dag");
    return node as SatNode;
  }

  numberOfHistorySteps(): number {
    let counter = 0;
    for (const node of this.nodes.values()) {
      if (node.activeTime !== null) {
        counter += 1;
      }
    }
    return counter;
  }

  isEmpty(): boolean {
    return this.nodes.size === 0;
  }

  getChildren(nodeId: number): Array<number> {
    if(!this.nodes.has(nodeId)) {
      assert(false, "Node with id " + nodeId + " does not occur in Dag");
    }

    const children = new Array<number>();
    for (const node of this.nodes.values()) {
      for (const parentId of node.parents) {
        if (parentId === nodeId) {
          children.push(node.id);
        }
      }
    }
    return children;
  }

  /* we can partition all nodes of the derivation into three sets
   * 1) inputNodes: the nodes given to Vampire's preprocessing as input
   * 2) preprocessingResultNodes: the nodes remaining at the end of Vampire's preprocessing, (which are then used as input for saturation)
   * 3) otherNodes: the nodes generated by saturation
   *
   * this function decides for a given node whether it should be treated as input node, using the following idea:
   * 1) input nodes occur before saturation is started and are therefore tagged with "isFromPreprocessing"
   * 2) in order to distinguish inputNodes from preprocessingResultNodes:
   *    - if node has a parent, it must be a preprocessingResultNode
   *    - if node has no parent, but a child which is not tagged "isFromPreprocessing", it must be a preprocessingResultNode (e.g. an internally added theory axiom)
   *    - otherwise assume it is an input node
   *    - if a node has no parents (as done for e.g. internal theory axioms), and if it has no children (which should happen rarily, in particular not for theory axioms),
   *      then this could wrongly classify a preprocessingResultNode as inputNode.
   */ 
  nodeIsInputNode(nodeId: number): boolean {
    assert(this.nodes.has(nodeId), "node doesn't occur in Dag");
    const node = this.get(nodeId);

    if (!node.isFromPreprocessing) {
      return false;
    }
    if(node.parents.length > 0) {
      return false;
    }
    const childrenIds = this.getChildren(nodeId);
    for (const childId of childrenIds) {
      const childNode = this.get(childId);
      if (!childNode.isFromPreprocessing) {
        return false;
      }
    }
    return true;
  }

  static fromSetOfNodes(nodes: Set<SatNode>): Dag {
    const nodeDict = new Map<number,SatNode>();
    for (const node of nodes) {
      nodeDict.set(node.id,node);
    }
    return new Dag(nodeDict);
  }

  // either 1) create a new dag given an array of parsed lines and no existing dag,
  // or     2) extend an existing dag with an array of parsed lines
  // In case 2) we assume that all the parsedLines are generated during Saturation, i.e. no additional preprocessing occurs.
  static fromParsedLines(parsedLines: Array<ParsedLine>, existingDag: Dag | null): Dag {
    const newNodes = (existingDag === null) ? new Map<number, SatNode>() : new Map<number, SatNode>(existingDag.nodes);
    let currentNode: SatNode | null = null;
    let currentTime = (existingDag === null) ? 0 : existingDag.numberOfHistorySteps();

    let emptyClauseNode: SatNode | null = null;

    for (const line of parsedLines) {
      if (line.type === "preprocessing") {
        // line represents the generation of a clause during preprocessing
        assert(existingDag === null, "no new preprocessing lines should occur while extending existing dag with new nodes from saturation")
        assert(!newNodes.has(line.id), "each clause must be generated by preprocessing only once");
        const unit = UnitParser.parseUnit(line.unitString, true, line.statistics);
        currentNode = new SatNode(line.id, unit, line.inferenceRule, line.parents, line.statistics, true, currentTime, null, null, null, []);
        newNodes.set(currentNode.id, currentNode);
      }
      else if (line.type === "new") {
        if (!newNodes.has(line.id)) {
          // line represents the generation of a new clause (which wasn't generated in preprocessing) during saturation
          assert(existingDag == null, "extending dag with lines from saturation, so all final clauses from preprocessing should already been added as new clauses!")
          // create new node
          const unit = UnitParser.parseUnit(line.unitString, false, line.statistics);
          currentNode = new SatNode(line.id, unit, line.inferenceRule, line.parents, line.statistics, false, currentTime, null, null, null, []);
          newNodes.set(currentNode.id, currentNode);

          if(line.unitString === "$false") {
            emptyClauseNode = currentNode;
          }
        } else {
          // line represents a final clause from preprocessing, which now is added into saturation
          currentNode = newNodes.get(line.id) as SatNode;
          assert(currentNode.isFromPreprocessing, "a newly added clause can only already exist if it was generated during preprocessing");
          assert(line.inferenceRule === currentNode.inferenceRule, "inference rule differs between line and existing node");
          currentNode.newTime = currentTime;
        }
      }
      else if (line.type === "passive") {
        // line represents the insertion of an already generated clause into the set of passive clauses
        assert(newNodes.has(line.id), `Found clause with id ${line.id}, which was added to passive, but wasn't added as new before. Maybe you forgot to output the new clauses?`);
        currentNode = newNodes.get(line.id) as SatNode;
        assert(line.inferenceRule === currentNode.inferenceRule, "inference rule differs between line and existing node");
        assert(line.parents.length === currentNode.parents.length, "number of parents differs between line and existing node");
        for (let i = 0; i < line.parents.length; i++) {
          assert(line.parents[i] === currentNode.parents[i], `line and node differ on parent ${i}, which is ${line.parents[i]} resp. ${currentNode.parents[i]}.`);
        }
        assert(currentNode.newTime !== null, "for each event [SA] passive ... there has to be an earlier event of the form [SA] new ... with the same clause!")
        assert((currentNode.newTime as number) <= currentTime, "invar");
        assert(currentNode.passiveTime == null, "there must only be 1 event of the form [SA] passive ... for each clause");
        currentNode.passiveTime = currentTime;
      }
      else if (line.type === "active") {
        // line represents the removal of an already generated clause from passive and the addition of that clause to active
        assert(newNodes.has(line.id), `Found clause with id ${line.id}, which was added to active, but wasn't added to passive before. Maybe you forgot to output the passive clauses?`);
        currentNode = newNodes.get(line.id) as SatNode;
        assert(line.id === currentNode.id, "id differs between line and existing node");
        assert(line.inferenceRule === currentNode.inferenceRule, "inference rule differs between line and existing node");
        assert(line.parents.length === currentNode.parents.length, "number of parents differs between line and existing node");
        for (let i = 0; i < line.parents.length; i++) {
          assert(line.parents[i] === currentNode.parents[i], `line and node differ on parent ${i}, which is ${line.parents[i]} resp. ${currentNode.parents[i]}.`);
        }
        assert(currentNode.newTime !== null, "for each event [SA] active ... there has to be an earlier event of the form [SA] new ... with the same clause!")
        assert(currentNode.passiveTime !== null, "for each event [SA] active ... there has to be an earlier event of the form [SA] passive ... with the same clause!")
        assert((currentNode.passiveTime as number) <= currentTime, "invar");
        assert(currentNode.activeTime == null, "there must only be 1 event of the form [SA] active ... for each clause");

        currentNode.statistics = line.statistics
        currentNode.unit = UnitParser.parseUnit(line.unitString, false, line.statistics);

        currentTime = currentTime + 1;
        currentNode.activeTime = currentTime;
      }
      else if (line.type === "forward reduce" || line.type === "backward reduce") {
        // line represents the removal of a clause from saturation
        assert(newNodes.has(line.id), `Found clause with id ${line.id}, which was deleted, but wasn't added as new before. Maybe you forgot to output the new clauses?`);
        currentNode = newNodes.get(line.id) as SatNode;
        currentNode.deletionTime = currentTime;
      }
      else if (line.type === "replaced by" || line.type === "using") {
        // line represents one of the clauses which allowed to remove the clause represented by currentNode from saturation
        assert(currentNode !== null, "invar");
        (currentNode as SatNode).deletionParents.push(line.id);
      }
      else {
        assert(false, `invalid line: ${line.unitString}`);
      }
    }

    // hack: pretend that empty clause was added to passive and then activated
    // note that this can only be done after all lines are parsed, since a new-event with the empty clause often triggers a deletion-event
    if (emptyClauseNode !== null) {
      emptyClauseNode.passiveTime = currentTime;
      currentTime = currentTime + 1;
      emptyClauseNode.activeTime = currentTime;
      newNodes.set(emptyClauseNode.id, emptyClauseNode);
    }

    const extendedDag = new Dag(newNodes);
    return extendedDag;
  }

  // note: includes nodes which have been activated, but have also been deleted
  computeActiveNodes(currentTime: number) : Set<number> {
    const activeNodeIds = new Set<number>();
    for (const [nodeId, node] of this.nodes) {
      const nodeIsActive = (node.activeTime !== null && node.activeTime <= currentTime);
      if (nodeIsActive) {
        activeNodeIds.add(nodeId);
      }
    }

    return activeNodeIds;
  }

  // Definition: the active dag contains all nodes which occur in the derivation of a currently active node
  computeNodesInActiveDag(currentTime: number) : Set<number> {
    const nodeIds = this.computeActiveNodes(currentTime);

	  // add all transitive parents of nodeIds to nodeIds
	  const iterator = new ReversePostOrderTraversal(this);
	  while (iterator.hasNext()) {
		  const currentNode = iterator.getNext();
      const currentNodeId = currentNode.id;
    
      if (nodeIds.has(currentNodeId)) {
        for (const parentId of currentNode.parents) {
          nodeIds.add(parentId);
        }
      }    
    }

    return nodeIds;
  }
}