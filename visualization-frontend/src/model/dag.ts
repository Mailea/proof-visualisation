import SatNode from './sat-node';
import { assert } from './util';
import { UnitParser } from './unit-parser';
import { ReversePostOrderTraversal } from "./traversal";

export class ParsedLine {
  readonly type: "preprocessing" | "new" | "passive" | "active" | "forward reduce" | "backward reduce" | "replaced by" | "using";
  readonly id: number;
  readonly unitString: string;
  readonly inferenceRule: string;
  readonly parents: Array<number>;
  readonly statistics: Map<any, any>; 

  constructor(type: "preprocessing" | "new" | "passive" | "active" | "forward reduce" | "backward reduce" | "replaced by" | "using", id: number, unitString: string, inferenceRule: string, parents: Array<number>, statistics: Map<any, any>) {
    this.type = type;
    this.id = id;
    this.unitString = unitString;
    this.inferenceRule = inferenceRule;
    this.parents = parents;
    this.statistics = statistics;
  }
}

export default class Dag {

  // TODO: it seems that the result of Graphviz depends on the order of node- and edge declarations.
  //       the order of these declarations depends on the order in which the nodes occur in the nodes-Map.
  //       therefore it could make sense to normalize the order of nodes in the nodes-Map at construction time of the Dag.
  readonly nodes: Map<number,SatNode>;
  readonly leaves: Set<number>;

  constructor(nodes: Map<number,SatNode>) {
    this.nodes = nodes;

    // sanity check: key and id of node need to match
    for (const [nodeId, node] of nodes) {
      assert(nodeId === node.id, `key ${nodeId} and id ${node.id} of node ${node} don't match!`);
    }

    // sanity check: each parentId needs to occur in the derivation as node
    for (const [nodeId, node] of nodes) {
      for (const parentId of node.parents) {
        assert(nodes.has(parentId), `node ${nodeId} has parent ${parentId} which does not occur as node in the dag!`);
      }
    }
    // compute leaves
    const leaves: Set<number> = new Set();
    const nonLeaves: Set<number> = new Set();
    
    for (const node of nodes.values()) {
      for (const parentId of node.parents) {
        nonLeaves.add(parentId);
      }
    }

    for (const nodeId of nodes.keys()) {
      if(!nonLeaves.has(nodeId)) {
        leaves.add(nodeId);
      }
    }

    this.leaves = leaves;
  }

  get(nodeId: number): SatNode {
    assert(this.nodes.has(nodeId), "node doesn't occur in Dag");
    return this.nodes.get(nodeId) as SatNode;
  }

  numberOfHistorySteps(): number {
    let counter = 0;
    for (const node of this.nodes.values()) {
      if (node.activeTime !== null) {
        counter += 1;
      }
    }
    return counter;
  }

  isEmpty(): boolean {
    return this.nodes.size === 0;
  }

  getChildren(nodeId: number): Array<number> {
    if(!this.nodes.has(nodeId)) {
      assert(false, "Node with id " + nodeId + " does not occur in Dag");
    }

    const children = new Array<number>();
    for (const node of this.nodes.values()) {
      for (const parentId of node.parents) {
        if (parentId === nodeId) {
          children.push(node.id);
        }
      }
    }
    return children;
  }

  /* we can partition all nodes of the derivation into three sets
   * 1) inputNodes: the nodes given to Vampire's preprocessing as input
   * 2) preprocessingResultNodes: the nodes remaining at the end of Vampire's preprocessing, (which are then used as input for saturation)
   * 3) otherNodes: the nodes generated by saturation
   *
   * this function decides for a given node whether it should be treated as input node, using the following idea:
   * 1) input nodes occur before saturation is started and are therefore tagged with "isFromPreprocessing"
   * 2) in order to distinguish inputNodes from preprocessingResultNodes:
   *    - if node has a parent, it must be a preprocessingResultNode
   *    - if node has no parent, but a child which is not tagged "isFromPreprocessing", it must be a preprocessingResultNode (e.g. an internally added theory axiom)
   *    - otherwise assume it is an input node
   *    - if a node has no parents (as done for e.g. internal theory axioms), and if it has no children (which should happen rarily, in particular not for theory axioms),
   *      then this could wrongly classify a preprocessingResultNode as inputNode.
   */ 
  nodeIsInputNode(nodeId: number): boolean {
    assert(this.nodes.has(nodeId), "node doesn't occur in Dag");
    const node = this.get(nodeId);

    if (!node.isFromPreprocessing) {
      return false;
    }
    if(node.parents.length > 0) {
      return false;
    }
    const childrenIds = this.getChildren(nodeId);
    for (const childId of childrenIds) {
      const childNode = this.get(childId);
      if (!childNode.isFromPreprocessing) {
        return false;
      }
    }
    return true;
  }

  static fromSetOfNodes(nodes: Set<SatNode>): Dag {
    const nodeDict = new Map<number,SatNode>();
    for (const node of nodes) {
      nodeDict.set(node.id,node);
    }
    return new Dag(nodeDict);
  }

  static fromDto(dto: any): Dag {
    const nodeDict = new Map<number,SatNode>();

    Object.values(dto.nodes).forEach((node: any) => nodeDict.set(node.number, SatNode.fromDto(node)));
    return new Dag(nodeDict);
  }

  // either 1) create a new dag given an array of parsed lines and no existing dag,
  // or     2) extend an existing dag with an array of parsed lines
  // In case 2) we assume that all the parsedLines are generated during Saturation, i.e. no additional preprocessing occurs.
  static fromParsedLines(parsedLines: Array<ParsedLine>, existingDag: Dag | null): Dag {
    const newNodes = (existingDag === null) ? new Map<number, SatNode>() : new Map<number, SatNode>(existingDag.nodes);
    let currentNode: SatNode | null = null;
    let currentTime = (existingDag === null) ? 0 : existingDag.numberOfHistorySteps();

    let emptyClauseNode: SatNode | null = null;

    for (const line of parsedLines) {
      if (line.type === "preprocessing") {
        // line represents the generation of a clause during preprocessing
        assert(existingDag === null, "no new preprocessing lines should occur while extending existing dag with new nodes from saturation")
        assert(!newNodes.has(line.id), "each clause must be generated by preprocessing only once");
        const unit = UnitParser.parseUnit(line.unitString, true, line.statistics);
        currentNode = new SatNode(line.id, unit, line.inferenceRule, line.parents, line.statistics, true, currentTime, null, null, null, []);
        newNodes.set(currentNode.id, currentNode);
      }
      else if (line.type === "new") {
        if (!newNodes.has(line.id)) {
          // line represents the generation of a new clause (which wasn't generated in preprocessing) during saturation
          assert(existingDag == null, "extending dag with lines from saturation, so all final clauses from preprocessing should already been added as new clauses!")
          // create new node
          const unit = UnitParser.parseUnit(line.unitString, false, line.statistics);
          currentNode = new SatNode(line.id, unit, line.inferenceRule, line.parents, line.statistics, false, currentTime, null, null, null, []);
          newNodes.set(currentNode.id, currentNode);

          if(line.unitString === "$false") {
            emptyClauseNode = currentNode;
          }
        } else {
          // line represents a final clause from preprocessing, which now is added into saturation
          currentNode = newNodes.get(line.id) as SatNode;
          assert(currentNode.isFromPreprocessing, "a newly added clause can only already exist if it was generated during preprocessing");
          assert(line.inferenceRule === currentNode.inferenceRule, "inference rule differs between line and existing node");
          currentNode.newTime = currentTime;
        }
      }
      else if (line.type === "passive") {
        // line represents the insertion of an already generated clause into the set of passive clauses
        assert(newNodes.has(line.id), `Found clause with id ${line.id}, which was added to passive, but wasn't added as new before. Maybe you forgot to output the new clauses?`);
        currentNode = newNodes.get(line.id) as SatNode;
        assert(line.inferenceRule === currentNode.inferenceRule, "inference rule differs between line and existing node");
        assert(line.parents.length === currentNode.parents.length, "number of parents differs between line and existing node");
        for (let i = 0; i < line.parents.length; i++) {
          assert(line.parents[i] === currentNode.parents[i], `line and node differ on parent ${i}, which is ${line.parents[i]} resp. ${currentNode.parents[i]}.`);
        }
        assert(currentNode.newTime !== null, "for each event [SA] passive ... there has to be an earlier event of the form [SA] new ... with the same clause!")
        assert((currentNode.newTime as number) <= currentTime, "invar");
        assert(currentNode.passiveTime == null, "there must only be 1 event of the form [SA] passive ... for each clause");
        currentNode.passiveTime = currentTime;
      }
      else if (line.type === "active") {
        // line represents the removal of an already generated clause from passive and the addition of that clause to active
        assert(newNodes.has(line.id), `Found clause with id ${line.id}, which was added to active, but wasn't added to passive before. Maybe you forgot to output the passive clauses?`);
        currentNode = newNodes.get(line.id) as SatNode;
        assert(line.id === currentNode.id, "id differs between line and existing node");
        assert(line.inferenceRule === currentNode.inferenceRule, "inference rule differs between line and existing node");
        assert(line.parents.length === currentNode.parents.length, "number of parents differs between line and existing node");
        for (let i = 0; i < line.parents.length; i++) {
          assert(line.parents[i] === currentNode.parents[i], `line and node differ on parent ${i}, which is ${line.parents[i]} resp. ${currentNode.parents[i]}.`);
        }
        assert(currentNode.newTime !== null, "for each event [SA] active ... there has to be an earlier event of the form [SA] new ... with the same clause!")
        assert(currentNode.passiveTime !== null, "for each event [SA] active ... there has to be an earlier event of the form [SA] passive ... with the same clause!")
        assert((currentNode.passiveTime as number) <= currentTime, "invar");
        assert(currentNode.activeTime == null, "there must only be 1 event of the form [SA] active ... for each clause");

        currentNode.statistics = line.statistics
        currentNode.unit = UnitParser.parseUnit(line.unitString, false, line.statistics);

        currentTime = currentTime + 1;
        currentNode.activeTime = currentTime;
      }
      else if (line.type === "forward reduce" || line.type === "backward reduce") {
        // line represents the removal of a clause from saturation
        assert(newNodes.has(line.id), `Found clause with id ${line.id}, which was deleted, but wasn't added as new before. Maybe you forgot to output the new clauses?`);
        currentNode = newNodes.get(line.id) as SatNode;
        currentNode.deletionTime = currentTime;
      }
      else if (line.type === "replaced by" || line.type === "using") {
        // line represents one of the clauses which allowed to remove the clause represented by currentNode from saturation
        assert(currentNode !== null, "invar");
        (currentNode as SatNode).deletionParents.push(line.id);
      }
      else {
        assert(false, `invalid line: ${line.unitString}`);
      }
    }

    // hack: pretend that empty clause was added to passive and then activated
    // note that this can only be done after all lines are parsed, since a new-event with the empty clause often triggers a deletion-event
    if (emptyClauseNode !== null) {
      emptyClauseNode.passiveTime = currentTime;
      currentTime = currentTime + 1;
      emptyClauseNode.activeTime = currentTime;
      newNodes.set(emptyClauseNode.id, emptyClauseNode);
    }

    const extendedDag = new Dag(newNodes);
    return extendedDag;
  }

  // note: includes nodes which have been activated, but have also been deleted
  computeActiveNodes(currentTime: number) : Set<number> {
    const activeNodeIds = new Set<number>();
    for (const [nodeId, node] of this.nodes) {
      const nodeIsActive = (node.activeTime !== null && node.activeTime <= currentTime);
      if (nodeIsActive) {
        activeNodeIds.add(nodeId);
      }
    }

    return activeNodeIds;
  }

  // returns null if node was not derived using simplification
  // returns id of original node if node was derived using simplification
  nodeWasDerivedUsingSimplification(nodeId: number): number | null {
    const node = this.get(nodeId);

    // one of the parents p of node n needs to satisfy the following four properties (independently from the currentTime):
    for (const parentId of node.parents) {
      const parent = this.get(parentId);
      // 1) p has been deleted
      // 2) the deletionTime of p matches the newTime of n.
      // 3) the first deletion parent of p is n
      // 4) let P be the set of parents of n other than p. Then the deletion parents of p are n and P.
      if (parent.deletionTime != null && parent.deletionTime == node.newTime && parent.deletionParents[0] === nodeId && node.parents.length == parent.deletionParents.length) {
        const set1 = new Set<number>(node.parents);
        set1.delete(parentId);
        const set2 = new Set<number>(parent.deletionParents);
        set2.delete(parent.deletionParents[0]);
        let otherParentsMatch = true;
        for (const e of set1) {
          if (!set2.has(e)) {
            otherParentsMatch = false;
          }
        }
        if (otherParentsMatch) {
          return parentId;
        }
      }
    }
    return null;
  }

  // computes the set of clauses currently in Passive, which are derived as children from nodes in selection (or are in the selection for the special case of final preprocessing nodes which are in passive)
  // precondition: selection contains only ids from nodes which either 1) have already been activated or 2) are final preprocessing clauses
  computePassiveNodesForSelection(currentTime: number, selection: Set<number>): Set<number> {
    const passiveNodeIds = new Set<number>();

    for (let [nodeId, node] of this.nodes) {
      // a node is in passive, if the new-event happened, but neither an active-event nor a deletion-event happened.
      const nodeIsInPassive = ((node.newTime !== null && node.newTime <= currentTime) && !(node.activeTime !== null && node.activeTime <= currentTime) && !(node.deletionTime !== null && node.deletionTime <= currentTime));
      if (nodeIsInPassive) {
        // compute active clauses or final preprocessing clauses from which node was generated

        // first go up in the derivation until the current node was not derived using a simplification
        while (true) {
          const nodeIdOrNull = this.nodeWasDerivedUsingSimplification(nodeId);
          if (nodeIdOrNull !== null) {
            assert(this.get(nodeIdOrNull).deletionTime != null);
            nodeId = nodeIdOrNull;
            node = this.get(nodeId);
          } else {
            break;
          }
        }

        // now either the current node is a preprocessing node, or the parents of the current node are active nodes
        if (node.isFromPreprocessing) {
          if (selection.has(nodeId)) {
            passiveNodeIds.add(nodeId);
          }
        } else {
          for (const parentId of node.parents) {
            const parent = this.get(parentId);
            
            assert(parent.activeTime != null && node.newTime != null && parent.activeTime <= node.newTime, `invar violated for node ${node}`);
          }
          for (const parentId of node.parents) {
            if (selection.has(parentId)) {
              passiveNodeIds.add(parentId);
            }
          }
        }
      }
    }
    return passiveNodeIds;
  }

  // Definition: the active dag contains all nodes which occur in the derivation of a currently active node
  computeNodesInActiveDag(currentTime: number) : Set<number> {
    const nodeIds = this.computeActiveNodes(currentTime);

	  // add all transitive parents of nodeIds to nodeIds
	  const iterator = new ReversePostOrderTraversal(this);
	  while (iterator.hasNext()) {
		  const currentNode = iterator.getNext();
      const currentNodeId = currentNode.id;
    
      if (nodeIds.has(currentNodeId)) {
        for (const parentId of currentNode.parents) {
          nodeIds.add(parentId);
        }
      }    
    }

    return nodeIds;
  }

  // precondition: selection contains only ids from nodes which either 1) have already been activated or 2) are final preprocessing clauses
  computeNodesInActiveAndPassiveDag(currentTime: number, selection: Set<number>) : Set<number> {
    const nodeIds = this.computeActiveNodes(currentTime);
    const passiveNodeIds = this.computePassiveNodesForSelection(currentTime, selection);
    for (const nodeId of passiveNodeIds) {
      nodeIds.add(nodeId);
    }

    // add all transitive parents of nodes in nodes
	  const iterator = new ReversePostOrderTraversal(this);
	  while (iterator.hasNext()) {
		  const currentNode = iterator.getNext();
      const currentNodeId = currentNode.id;
    
      if (nodeIds.has(currentNodeId)) {
        for (const parentId of currentNode.parents) {
          nodeIds.add(parentId);
        }
      }    
    }

    return nodeIds;
  }

}
