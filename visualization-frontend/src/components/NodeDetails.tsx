import * as React from 'react';

import './NodeDetails.css';
import Sortable from 'react-sortablejs';
import {Clause} from '../model/unit';
import {Literal} from '../model/literal';
import SatNode from '../model/sat-node';
import {assert} from '../model/util';

const icons = require('../resources/icons/all.svg') as string;

type Props = {
  node: SatNode,
  numberOfTransitiveActivatedChildren: number,
  onLiteralOrientationChange: (nodeId: number, oldPosition: ["premise" | "conclusion" | "context", number], newPosition: ["premise" | "conclusion" | "context", number]) => void,
  onLiteralRepresentationChange: (nodeId: number, literal: Literal) => void
};

export default class NodeDetails extends React.Component<Props, {}> {
  state = {
    draggable: false,
    infoToggle: false,
    editToggle: false
  };

  keep=true; // hack to skip each second event generated by Sortable

  render() {
    const statisticsStrings = new Array<string>();
    for (const [key, value] of this.props.node.statistics) {
      if (!['nSel', 'inD'].includes(key)) {
        statisticsStrings.push(`${key}: ${value}`);
      }
    }

    return (
      <section
        className={'component-node-details details'}
      >
        <article>
          <h2>Node <strong>{this.props.node.id}</strong></h2>

          <div className="button-bar">
            <button
              className={'toggle-button' + (this.state.infoToggle ? ' toggled': '')}
              title={ this.state.infoToggle ? 'Hide statistics': 'Show statistics' }
              onClick={this.toggleInfo.bind(this)}
            >
              <svg viewBox="0 0 24 24" className="icon">
                <use xlinkHref={`${icons}#toggle-info`}/>
              </svg>
            </button>
            <button
              className={'toggle-button' + (this.state.editToggle ? ' toggled': '')}
              title={ this.state.editToggle ? 'Terminate edit mode': 'Enter edit mode' }
              onClick={this.toggleEdit.bind(this)}
            >
              <svg viewBox="0 0 24 24" className="icon">
                <use xlinkHref={`${icons}#toggle-edit`}/>
              </svg>
            </button>
          </div>

          <h3>
            {this.props.node.inferenceRule},
            <br/>
            {this.props.numberOfTransitiveActivatedChildren} {this.props.numberOfTransitiveActivatedChildren === 1 ? 'child' : 'children'}
          </h3>
          {
            this.state.infoToggle && <ul className="stats">{ statisticsStrings.map(string => <li>{string}</li>) }</ul>
          }

          {
            this.props.node.unit.type === "Formula" ? (
              <section className={'literal-wrapper'}>
                {
                  this.props.node.toString()
                }
              </section>
            ) : (
              <section
                className={'literal-wrapper' + (this.state.draggable ? ' drag' : '')}
                onMouseEnter={() => this.setState({draggable: true})}
                onMouseLeave={() => this.setState({draggable: false})}
              >
                {
                  this.toList(this.props.node.id, this.props.node.unit as Clause, "premise")
                }
                <span className={'separator separator-arrow count-' + (this.props.node.unit as Clause).premiseLiterals.length}>{'\u2192'}</span>
                {
                  this.toList(this.props.node.id, this.props.node.unit as Clause, "conclusion")
                }
                <span className={'separator separator-line count-' + (this.props.node.unit as Clause).contextLiterals.length}>&nbsp;</span>
                {
                  this.toList(this.props.node.id, this.props.node.unit as Clause, "context")
                }
              </section>
            )
          }
        </article>
      </section>
    );
  }

  toList = (nodeId: number, clause: Clause, orientation: "premise" | "conclusion" | "context") => {
    const literals = orientation === "premise" ? clause.premiseLiterals : (orientation === "conclusion" ? clause.conclusionLiterals : clause.contextLiterals);

    return (
      <Sortable
        options={{
          group: 'shared'
        }}
        tag={"ul"}
        id={orientation === "premise" ? "id1" : (orientation === "conclusion" ? "id2" : "id3")}
        onChange={(_items, _sortable, event)=>{
          // Hack: If from and to are different, then Sortable generates two identical events (one for each modified list), 
          // so we ignore the latter one using the flag this.keep
          const from = event.from.id === "id1" ? "premise" : event.from.id === "id2" ? "conclusion" : "context";
          const to = event.to.id === "id1" ? "premise" : event.to.id === "id2" ? "conclusion" : "context";
          if (from === to) {
            assert(this.keep);
          }
          if (this.keep) {
            this.props.onLiteralOrientationChange(nodeId, [from, event.oldIndex], [to, event.newIndex]);
          }
          if (from !== to) {
            this.keep = !this.keep;
          }
        }}
      >
        {
          literals.map((literal, index) => this.toListItem(literal, index, orientation))
        }
      </Sortable>
      )
    };

  toListItem = (literal: Literal, index: number, orientation: "premise" | "conclusion" | "context") => {
    return <li key={index} data-id={index} onDoubleClick={(event) => {
      this.props.onLiteralRepresentationChange(this.props.node.id, literal);
      event.currentTarget.innerText = literal.toString(orientation === "premise");
    }}>{literal.toString(orientation === "premise")}</li>
  };

  toggleInfo() {
    this.setState({ infoToggle: !this.state.infoToggle });
  }

  toggleEdit() {
    this.setState({ editToggle: !this.state.editToggle });
  }
}
